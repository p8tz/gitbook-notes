**LeetCode&nbsp;&nbsp;260. Single Number III**

## 题目描述

给定一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。

```
输入: [1,2,1,3,2,5]
输出: [3,5]
```

注意：

1. 结果输出的顺序并不重要，对于上面的例子， `[5, 3]` 也是正确答案。
2. 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

## 解题思路

1. 全部异或, 得到那两个数的异或值
2. 任取这个数为`1`的那一位作为掩码
3. 然后根据掩码把数组分成两部分分别异或, 就得到答案

原因: 首先, 为`1`的那一位一定是这两个数不相同的那一位, 因此它们会被分到不同的一组. 其次相同的数一定会被分到相同的一组

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int x = 0;
        for (int num : nums) {
            x ^= num;
        }
        
        //  [x]原: 00101100
        //  [x]补: 00101100
        // [-x]原: 10101100
        // [-x]反: 11010011
        // [-x]补: 11010100
        
        // 获取最低位的1
        //  x: 00101100
        // -x: 11010100
		//  &: 00000100
        int mask = x & (-x);
        int[] ans = new int[2];
        for (int num : nums) {
            if ((num & mask) == 0) {
                ans[0] ^= num;        
            } else {
                ans[1] ^= num;
            }
        }
        return ans;
    }
}
```
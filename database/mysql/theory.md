## 一. 范式

以一个例子说明范式的作用, 例子来源: [牛蛙的大杂烩](https://zhuanlan.zhihu.com/p/20028672)

第一范式就是说属性列不可再分, 下表已经满足第一范式

| 学号  | 姓名 | 系名     | 系主任 | 课名         | 分数 |
| ----- | ---- | -------- | ------ | ------------ | ---- |
| 95001 | 李勇 | 数学系   | 张清玫 | 复变函数     | 80   |
| 95001 | 李勇 | 数学系   | 张清玫 | 大学英语     | 90   |
| 95001 | 李勇 | 数学系   | 张清玫 | 数学分析     | 70   |
| 95002 | 刘晨 | 计算机系 | 刘逸   | 数据结构     | 65   |
| 95002 | 刘晨 | 计算机系 | 刘逸   | Java程序设计 | 90   |
| 95002 | 刘晨 | 计算机系 | 刘逸   | 数据库原理   | 65   |
| 95003 | 王敏 | 数学系   | 张清玫 | 复变函数     | 80   |
| 95003 | 王敏 | 数学系   | 张清玫 | 红楼梦赏析   | 85   |

### 问题

数据冗余: 出现大量重复数据

修改异常: 如果王敏转到计算机系, 需要修改三条记录, 容易出现数据不一致性

插入异常: 学校新建了一个系，但是暂时还没有招收任何学生，那么是无法将系名与系主任的数据单独地添加到数据表中去的(主属性不能为空)

删除异常: 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了

### 基本概念及解决方案

#### 函数依赖

**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作$$X\stackrel{}{\rightarrow}Y$$**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。

#### 完全函数依赖

在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**，记作 $$X\stackrel{F}{\rightarrow}Y$$

#### 部分函数依赖

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作$$X\stackrel{P}{\rightarrow}Y$$

#### 传递函数依赖

假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作$$X\stackrel{T}{\rightarrow}Y$$

#### 码

设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主码**）

#### 主属性

包含在任意一个码中的属性称为主属性。

#### 非主属性

不包含在任何一个码中的属性称为非主属性。

#### 修正为第二范式

上表的码只有一个，就是**（学号、课名）**

所以主属性有两个：**学号** 与 **课名**, 其余的都是非主属性

对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 **系名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性 **系主任** 对码**（学号，课名）**的部分函数依赖。

所以商标存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。

一个满足第二范式的拆表如下

| 学号  | 课名         | 分数 |
| ----- | ------------ | ---- |
| 95001 | 复变函数     | 80   |
| 95001 | 大学英语     | 90   |
| 95001 | 数学分析     | 70   |
| 95002 | 数据结构     | 65   |
| 95002 | Java程序设计 | 90   |
| 95002 | 数据库原理   | 65   |
| 95003 | 复变函数     | 80   |
| 95003 | 红楼梦赏析   | 85   |

| 学号  | 姓名 | 系名     | 系主任 |
| ----- | ---- | -------- | ------ |
| 95001 | 李勇 | 数学系   | 张清玫 |
| 95002 | 刘晨 | 计算机系 | 刘逸   |
| 95003 | 王敏 | 数学系   | 张清玫 |

看看之前存在的问题有没有解决

数据冗余: 少了. ---- 有改进

修改异常: 王敏转到计算机系, 只需要修改一条记录. ---- 有改进

插入异常: 插入一个尚无学生的新系的信息。因为学生表的码是学号，不能为空，所以此操作不被允许. ---- 无改进

删除异常: 删除某个系中所有的学生记录该系的信息仍然全部丢失. ---- 无改进

所以还不够

#### 修正为第三范式

对于学生表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。

最终一个满足第三范式的拆表如下

| 学号  | 课名         | 分数 |
| ----- | ------------ | ---- |
| 95001 | 复变函数     | 80   |
| 95001 | 大学英语     | 90   |
| 95001 | 数学分析     | 70   |
| 95002 | 数据结构     | 65   |
| 95002 | Java程序设计 | 90   |
| 95002 | 数据库原理   | 65   |
| 95003 | 复变函数     | 80   |
| 95003 | 红楼梦赏析   | 85   |

| 学号  | 姓名 | 系名     |
| ----- | ---- | -------- |
| 95001 | 李勇 | 数学系   |
| 95002 | 刘晨 | 计算机系 |
| 95003 | 王敏 | 数学系   |

| 系名     | 系主任 |
| -------- | ------ |
| 数学系   | 张清玫 |
| 计算机系 | 刘逸   |

再看一下之前的问题

删除异常: 删除某个系中所有的学生记录, 该系的信息不会丢失。---- 有改进

插入异常: 插入一个尚无学生的新系的信息。因为系表与学生表目前是独立的两张表，所以不影响。---- 有改进

数据冗余: 更少了。---- 有改进

### 总结

**第一范式**：属性不可分

**第二范式**：消除对码的部分函数依赖, 每个非主属性都完全函数依赖于码。体现为在使用联合主键的情况下, 不存在联合主键中部分属性就可以确定其它属性

**第三范式**：消除对码的传递函数依赖, 每个非主属性不传递函数依赖于码。体现为使用外键关联其它实体信息

## 二. 事务

### ACID

原子性：事务的操作, 要么全部完成, 要么全都不完成

一致性：事务执行前后的数据状态一致，这里一致可以认为是说符合逻辑，比如A给B转账100这个事务执行完后，成功应看到A-100，B+100, 不成功应看到A, B，不能出现中间其它状态

隔离性：并发访问时, 不同事务之间相互隔离, 不受影响，具体隔离效果取决于隔离级别

持久性：一旦事务提交，所产生的变化是持久化在硬盘中的, 服务器宕机重启后读到的数据也是变化之后的

### 隔离级别

- 读未提交：一个事务可以读另一个事务**写未提交**的数据，会产生脏读的问题
- 读已提交：一个事务只能读另一个事务**写已提交**的数据, **即事务所做的修改在提交之前对其它事务不可见**. 可以解决脏读的问题，会产生不可重复读的问题
- 可重复读：一个事务内对同一条记录的读取总是一致的, 解决不可重复读的问题，会产生幻读的问题
- 可串行化：强制事务串行执行, 不会出现任何并发问题

|          | 丢失修改 | 脏读 | 不可重复读 | 幻读 |
| :------: | :------: | :--: | :--------: | :--: |
| 读未提交 |    Y     |  N   |     N      |  N   |
| 读已提交 |    Y     |  Y   |     N      |  N   |
| 可重复读 |    Y     |  Y   |     Y      |  N   |
| 可串行化 |    Y     |  Y   |     Y      |  Y   |

### 并发问题

1. 丢失修改: 两个事务先后对同一块数据进行**写**的操作, 导致先写入的事务修改结果丢失. mysql中不允许两个事务同时**写**一块数据, 因此不会出现这样的情况
2. 脏读：事务 A 读取了事务B更新的数据，然后B回滚操作，那么A读取到的就是脏数据
3. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了修改并提交，导致事务A多次读取同一数据时，结果不一致。
4. 幻读：幻读本质上也属于不可重复读的情况，事务 A 读取某个范围的数据，事务 B 在这个范围内插入新的数据，A 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

​		小结：不可重复读侧重于修改或删除，幻读侧重于新增。解决不可重复读的问题只需锁住对应的行(因为是对已存在的行操作)，解决幻读需要锁表(不知道哪里会插来数据)

### AUTOCOMMIT

mysql默认开启自动提交事务, 每条语句默认为一个事务. 如果显示开启start transaction则会关闭自动提交, 遇到COMMIT再提交

通过下面设置默认事务是否开启, 0关闭, 1开启

```mysql
SET AUTOCOMMIT = 0 | 1
```

## 三. 锁

### 锁粒度

行锁：开销大，加锁慢；会出现死锁，并发度高

表锁：开销小，加锁快；不会出现死锁，并发度低

### 读写锁

共享锁（读锁）：加了 S 锁后，别的事务仍然可以加 S 锁，但不能加 X 锁，加了锁的事务只能对数据进行读操作

排他锁（写锁）：加了 X 锁后，别的事务不能对其加任何锁，只有加了锁的事务可以操作数据

### 意向锁

由于表锁和行锁的范围不同，可能会产生冲突。在加表锁之前需要逐行判断有没有行锁，确认没有行锁才能加表锁，这样的判断方式肯定效率低下，由此出现了意向锁来解决行锁和表锁冲突的问题。意向锁分为读意向锁和写意向锁，二者都是表锁。当事务需要加读锁或写锁时，首先要加意向锁。这样加意向锁之前判断该表有没有意向锁就可以了

意向锁之间不会产生冲突，只会阻塞表级读锁和写锁，意向锁也不会和行锁冲突，只是相当于一个锁标志，告诉要加表锁的事务，我这个表有行锁，现在不能加表锁

### 补充

意向锁是 InnoDB 自动加的，不需用户干预。对于 `UPDATE`、``DELETE` 和 `INSERT` 语句，InnoDB会自动给涉及的数据集加排他锁（X)；对于普通`SELECT`语句，InnoDB 不会加任何锁；可以通过以下语句显示给记录集加共享锁或排他锁

```mysql
SELECT ... LOCK IN SHARE MODE # 共享锁(S)
SELECT ... FOR UPDATE 		  # 排他锁(X)
```

### 封锁协议

#### 一级封锁协议

写之前加 X 锁, 事务结束释放 X 锁. 实现了读未提交

> 因为不能对同一数据同时修改, 因此不会有丢失修改的问题

#### 二级封锁协议

在一级基础上, 读之前加 S 锁, 读完后释放 S 锁. 实现了读已提交

>  因为事务 A 修改数据时, 事务 B 不能加 S 锁, 也就不能读, 因此不会有脏读的问题

#### 三级封锁协议

在一级基础上, 读之前加 S 锁, 事务结束释放 S 锁. 实现了可重复读

> 因为事务 A 多次读数据的时候, 只要事务没结束, 就不能释放 S 锁, 其它释放也就不能加 X 锁修改, 因此不会有可重复读的问题

#### 两段锁协议

两段锁协议是一种能够实现并发调度可串行化的封锁协议. 两段锁规定:

1. 对数据 D 读之前加 S 锁, 写之前加 X 锁
2. 一旦在 D 上有锁释放, 则不能再给 D 加锁, 直到锁全部释放完

在遵循两段锁协议的事务中, 明显地可分为两个阶段: 第一阶段是锁逐步增加阶段, 第二阶段是锁逐步释放阶段

实现了可串行化

## 四. MVCC

> 原文链接: [CS-Notes](https://cyc2018.github.io/CS-Notes/#/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86?id=_1-%e5%bf%ab%e7%85%a7%e8%af%bb) [YoungChen](https://zhuanlan.zhihu.com/p/64576887)

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现`RC`和`RR`这两种隔离级别。

### 基本思想

在多级封锁协议中，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

### 当前读

对数据库进行修改的操作（`INSERT`、`UPDATE`、`DELETE`）需要进行加锁操作，从而读取最新的数据, 这就是当前读. `SELECT`可以强制加锁进行当前读

```mysql
SELECT * FROM ... FOR UPDATE;  		  # X
SELECT * FROM ... LOCK IN SHARE MODE; # S
```

### 快照读

不加锁的`SELECT`就是快照读

```mysql
SELECT * FROM ...;
```

### 版本号

系统版本号 `SYS_ID`：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。

事务版本号 `TRX_ID`：事务开始时的系统版本号。

### 隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的一些字段

![image-20201023222507671](https://gitee.com/p8t/picbed/raw/master/imgs/20201023222508.png)

`TRX_ID`
6字节，记录最近更新这条行记录的事务 ID

`ROLL_PTR`
7字节，回滚指针，指向这条记录的上一个版本. `InnoDB` 便是通过这个指针找到之前版本的数据。该行记录上的所有旧版本，在 `undo log` 中都通过链表的形式组织。

`ROW_ID`
6字节，隐含的自增ID（隐藏主键），如果数据表没有主键，可以作为聚簇索引

### undo log

MVCC 的多版本指的就是多个版本的快照，快照存储在`undo log`中，该日志通过回滚指针 `ROLL_PTR` 把一个数据行的所有快照连接起来。 **`SELECT`数据的过程就是查找版本链的过程**

注意下图只有旧数据在`undo log`中.

![image-20201023223341390](https://gitee.com/p8t/picbed/raw/master/imgs/20201023223342.png)

### Read View

在 `RU` 隔离级别下，直接读取版本的最新记录就可以，对于 `SERIALIZABLE` 隔离级别，则是通过加锁互斥来访问数据，不需要`MVCC`。因此`MVCC`运行在`RC`和`RR`这两个隔离级别下，当`InnoDB`隔离级别设置为其中之一时，在`SELECT`数据时就会用到版本链

#### RR 下的 ReadView 生成

在`RR`隔离级别下，每个事务`touch first read`时（本质上就是执行第一个 `SELECT` 语句时，后续所有的`SELECT`都是复用这个`ReadView`，其它 `UPDATE`, `DELETE`, `INSERT` 语句和一致性读 `snapshot` 的建立没有关系），会将当前系统中的所有的活跃事务(未提交事务)拷贝到一个列表生成`ReadView`。

#### RC 下的 ReadView 生成

在`RC`隔离级别下，每个`SELECT`语句开始时，都会重新将当前系统中的所有的活跃事务拷贝到一个列表生成`ReadView`。和`RR`区别就在于生成`ReadView`的时间点不同，一个是事务之后第一个`SELECT`语句开始、一个是事务中每条`SELECT`语句开始。

#### 执行流程

`ReadView` 中是当前活跃的事务 `ID` 列表，称之为 `m_ids`，其中最小值为 `up_limit_id`，最大值为 `low_limit_id`，事务 `ID` 是事务开启时 `InnoDB` 分配的，其大小决定了事务开启的先后顺序，因此我们可以通过 `ID` 的大小关系来决定版本记录的可见性，具体判断流程如下：

1. 如果被访问版本的 `trx_id` 小于 `m_ids` 中的最小值 `up_limit_id`，说明生成该版本的事务在 `ReadView` 生成前就已经提交了，所以该版本可以被当前事务访问。
2. 如果被访问版本的 `trx_id` 大于 `m_ids` 列表中的最大值 `low_limit_id`，说明生成该版本的事务在生成 `ReadView` 后才生成，所以该版本不可以被当前事务访问。需要根据 `Undo Log` 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性。
3. 如果被访问版本的 `trx_id` 属性值在 `m_ids` 列表中最大值和最小值之间（包含）
   1. 在`RC`隔离级别下, 就需要判断一下 `trx_id` 的值是不是在 `m_ids` 列表中。如果在，说明创建 `ReadView` 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 `DB_TRX_ID` 再从头计算一次可见性；如果不在，说明创建 `ReadView` 时生成该版本的事务已经被提交，该版本可以被访问。
   2. 在`RR`隔离级别下, 都不可访问(因为, 可能会有别的事务对其作了修改), 需要查找 Undo Log 链得到上一个版本，然后根据该版本的 `DB_TRX_ID` 再从头计算一次可见性
4. 此时经过一系列判断我们已经得到了这条记录相对 `ReadView` 来说的可见结果。此时，如果这条记录的 `delete_flag` 为 `true`，说明这条记录已被删除，不返回。否则说明此记录可以安全返回给客户端。

### 总结

1. 在`RR`隔离级别下, 一个事务对同一条记录只有第一次读产生`ReadView`, 然后通过查找版本链`(undo log)`找到符合要求的记录, 以后每次读取的数据都是这个, 因此前后读的数据是一致的
> 类比`Java`中`CopyOnWriteArrayList`

2. 在`RC`隔离级别下, 一个事务对同一条记录每次读都会产生一个`ReadView`, 每次都通过查找版本链`(undo log)`找到符合要求的记录, 因此前后读的数据是可能不一致的

## 五. 索引

### B树和B+树

**数据结构**

一颗m叉的B树特性如下：

- 树中每个节点最多包含m个孩子。
- 除根节点与叶子节点外，每个节点至少有`[ceil(m/2)]`个孩子。
- 若根节点不是叶子节点，则至少有两个孩子。
- 所有的叶子节点都在同一层。
- 每个非叶子节点由`n`个`key`与`n+1`个指针组成，其中`[ceil(m/2)-1] <= n <= m-1`

![image-20201022203816647](https://gitee.com/p8t/picbed/raw/master/imgs/20201022203817.png)

B+Tree为BTree的变种，区别为：

- n叉`B+Tree`最多含有`n`个`key`，而BTree最多含有`n-1`个key。
- `B+Tree`的叶子节点保存所有的key信息，依`key`大小顺序排列。
- 所有的非叶子节点都可以看作是`key`的索引部分。

![image-20201022211908229](https://gitee.com/p8t/picbed/raw/master/imgs/20201022211909.png)

**对比**

二叉搜索树 / AVL树 / 红黑树: 每个节点只存放一个索引, 树较高, 不利于磁盘IO

B树: 每个节点既存放索引也存放数据, 相比于红黑树提高了单页索引量, 但是因为数据和索引放在一起, 数据会挤占索引的空间, 可以进一步分离. 此外, 对于范围查找不方便

B+树: 只有叶子节点存放数据，其它的节点只存放索引，使得一个页可容纳的索引数量大大增加，并且每个叶子节点之间以链表的形式连接起来，极大提高了范围查找的效率

### MySQL中的索引

B+Tree索引：最常见的索引, 不需要全表扫描, 后面说的都是基于这种索引

Hash索引：基于哈希表实现，数组加链表，适用于精确查找，做不到范围查询, memory默认使用

R-tree 索引（空间数据索引）：MyISAM的一个特殊索引类型，可以用作地理数据存储。空间索引会从所有维度来索引数据, 可以有效地使用任意维度来组合查询。

Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。InnoDB从`MySQL5.6.4`版本开始支持全文索引。

### B+Tree索引分类

主键索引：唯一，不允许`null`值

唯一索引：唯一，只允许一个`null`值

普通索引：无限制

联合索引：多个属性组成一个索引

### 聚簇索引和非聚簇索引

聚簇索引: 索引和真正的数据放在一块, 也就是索引叶子节点存储了该行的数据

非聚簇索引: 叶子节点存的不是真正的数据, 可以是数据的起始地址, 也可以是主键索引的值

在InnoDB中, 每个表**有且仅有**一个聚簇索引，建表时会自动为`PRIMARY KEY`创建，如果没有主键则会找一个`NOT NULL UNIQUE`作为聚簇索引，如果还没有，则使用6字节的`row_id`作为聚簇索引. 
除了聚簇索引之外的都是非聚簇索引, 只有聚簇索引的叶子存储的是数据，其它索引存的都是主键值，然后通过主键再次查询得到数据，因此查询非聚簇索引会有两次查询过程，第二次称为**回表**

在MyISAM中, 索引叶子节点存的是数据的地址, 因此是非聚簇索引

### 概念

**单列索引**: 以单个字段建立的索引

**复合索引**: 以多个字段建立的索引, 又叫组合索引 / 联合索引

**前缀索引**: 对于比较长的字符类型的索引, 可以指定以前多少位来建立索引, 建立时应当注意: 索引部分尽可能的不重复, 否则效率大大降低

> 假设有一张表, 其中一个索引数据类型为100个字符, 截取前5个, 发现会有大量重复, 截取前7个, 重复大大降低, 则应当以前7个字符建立索引, 而不是以整个字段(100个字符)或前5个字符建立索引

#### 全值匹配

对于联合索引, 如果查询条件包含了其中每一个属性且均为AND连接的精确匹配, 则称为全值匹配

> 有联合索引 `id, name, age`, 对于SQL语句: `SELECT * FROM stu WHERE id=1 AND name='jljxvg' AND age=18`, 可以称为其索引的全值匹配

#### 最左前缀匹配

对于联合索引，查询时会从最左边开始匹配 (书写顺序不重要)，且中间不能缺, 否则从缺的开始都不算入索引

> 有联合索引 `id, name, age`, 则`id` / `id, name`/ `id, name, age`都是合法索引, 查询的时候都会走对应的索引; 而`id, age`虽然也会走索引, 但只走`id`, 相当于索引就是`id`; 对于`name, age`从左边开始一个都匹配不到, 因此不会走索引,执行全表查询
>
> 个人猜想原因: 联合索引越靠左边的属性, 排序的优先级越高, 如果跳过第二列则找不到这一列的范围, 就无法进行第三列的匹配. 而不跳过的话, 只需要把已经匹配的数据返回即可

#### 回表

查询非主键(聚簇)索引时，第一次查询得到主键值，第二次查询才得到数据，其中第二次查询过程称为回表

#### 索引覆盖

查询非主键索引不一定需要回表，只要保证查询的数据包含于联合索引即可

> 因为查询的数据全都在索引里面

#### 索引下推

如果没有ICP（Index Condition Pushdown），对于联合索引，查询的时候会先把满足第一个条件的主键查出来，然后回表，对数据在server层进行剩余条件筛选

有了ICP之后，查询的时候不会忽略剩余条件，直接在存储引擎进行筛选

### 索引优化

**结构修改**: 不要对频繁改动的列建立索引, 因此每次改动都会导致索引更新, 甚至重构, 索引越多, 时间越长

**覆盖索引**: 尽量使用覆盖索引, 这样不会进行回表查询(针对InnoDB), 提高效率

**全值匹配**：索引一定生效

**最左前缀匹配**：从缺的列开始, 后面的索引失效,. 因此建立联合索引应该把常用索引放左边

**范围查询**：范围查询之后的索引失效

> 有联合索引 `id, score`, age, 对于SQL语句: `SELECT * FROM stu WHERE id=1 AND score>60 AND age=18`, 走的索引为`id, score`

**字段运算**：对索引字段运算会导致索引失效

> 有索引name, 查询name第二个字为风的数据: `SELECT * FROM stu WHERE substring(name, 2, 1)='风'`, 此时索引失效

**字符串不加单引号**：索引失效，原因是优化器会加上单引号，相当于给索引字段进行了运算. 因此对于字符串一定要显示加上引号

### 索引失效

- 不满足最左前缀法的索引失效

- 范围查询之后的索引失效

- 对索引字段进行运算, 索引失效

- 字符串不加引号，索引失效

- 用`OR`连接的条件, 只要有一边没有建立索引, 那么索引失效
> 有索引`id`, 对于SQL语句: `SELECT * FROM stu WHERE id=1 OR name='xxx'`. 如果id走索引, 那么筛选name的时候还是要全表扫描, 因此没必要走索引, 直接全表扫描, 即索引失效

- 以%开头的like模糊查询，索引失效，可以通过覆盖索引来使索引生效, 但是这个生效并不是利用索引来定位数据, 而是遍历索引树, 因为数据都在树上. 
想要真正的解决可以建立一个冗余列, 把数据反转查询
> 有索引id, name
> 对于 `SELECT * FROM stu WHERE name LIKE '风%'`索引生效 
> 对于 `SELECT * FROM stu WHERE name LIKE '%风'`则索引失效
> 对于 `SELECT id FROM stu WHERE name LIKE '%风'`索引生效, 但并不是利用索引检索数据, 所以查询速度还是慢
> 对于 `SELECT * FROM stu WHERE number LIKE '%123', 可以建立冗余列, 数据为number的反转, 然后 `SELECT * FROM stu WHERE rev_number LIKE '321%',

- 如果MySQL评估全表扫描比索引快，则走全表扫描，索引失效
> 比如一张表有10条记录, 其中9条记录索引score均为90, 则查询`score=90`时, 不走索引

- IS  NULL ， IS NOT NULL  有时索引失效，原因和上面一样

- IN 走索引， NOT IN 索引失效
> 有索引`id`
> 对于 `SELECT * FROM stu WHERE id IN (1, 2, 3)`走索引
> 对于 `SELECT * FROM stu WHERE id NOT IN (1, 2, 3)`不走索引

## 六. 存储引擎

### InnoDB

InnoDB 存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM
的存储引擎，InnoDB 写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。

### MyISAM

MyISAM不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本上都可以使用 这个引擎来创建表。

### 对比
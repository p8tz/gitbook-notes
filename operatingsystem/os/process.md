## PCB

进程控制块（`Process Control Block`), 描述进程的数据结构

- PID: 操作系统唯一标识进程的标识符

## 进程调度

### 上下文切换

在进程的生命周期中, 进程实体和支持进程运行的环境合称为进程上下文(`Process Context`)

- 用户级上下文: 由进程的代码区、数据区、用户栈区和共享存储区组成,在编译目标文件时生成，占据进程的虚拟地址空间。进程的代码区是只读的程序指令，数据区存放的是程序运行时所需要的数据，用户栈区用来完成处理器运行时的过程调用和返回、参数传递等，共享内存区是与其他进程共享的部分。
- 系统级上下文: 由进程控制块、内存管理信息、进程环境块和系统栈等组成。
- 寄存器上下文: 由程序状态寄存器、各类控制寄存器、地址寄存器、通用寄存器和用户栈指针等组成。

当发生线程切换时, 把当前任务的寄存器数据保存到内存中, 将下一个要切换过来的线程的寄存器数据状态恢复, 使其继续执行, 同一时刻只允许一个线程独享寄存器。不同线程切换导致的寄存器数据切换就是上下文切换(`Context Switch`)

### 调度方式

1. 非剥夺调度方式，又称非抢占方式。

是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。 在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。 

2. 剥夺调度方式，又称抢占方式。

是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。

### 调度算法

> [郭威gowill](https://blog.csdn.net/guoweimelon/article/details/50847532?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.compare)

**调度算法的评价指标**

1）CPU利用率

CPU是计算机系统中的稀缺资源，所以应在有具体任务的情况下尽可能使CPU保持忙，从而使得CPU资源利用率最高。

CPU利用率 = CPU利用的时间 / 开机运行的总时间

2）吞吐量

CPU运行时的工作量大小是以每单位时间所完成的进程数目来描述的，即称为吞吐量。

3）周转时间

指从进程创建到作进程结束所经过的时间，这期间包括了由于各种因素（比如等待I/O操作完成）导致的进程阻塞，处于就绪态并在就绪队列中排队，在处理机上运行所花时间的总和。

作业的周转时间： 

周转时间 = 作业完成时间 - 作业提交时间 

平均周转时间是指多个作业周转时间的平均值： 

平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n 

带权周转时间是指作业周转时间与作业实际运行时间的比值： 

带权周转时间 = 作业周转时间 / 作业实际运行时间 

平均带权周转时间是指多个作业带权周转时间的平均值： 

平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n

4）等待时间

即进程在就绪队列中等待所花的时间总和。因此衡量一个调度算法的简单方法就是统计进程在就绪队列上的等待时间。

5）响应时间

指从事件（比如产生了一次时钟中断事件）产生到进程或系统作出响应所经过的时间。在交互式桌面计算机系统中，用户希望响应时间越快越好，但这常常要以牺牲吞吐量为代价。

**进程调度的常见算法**

1. 先来先服务调度算法（FCFS，First Come First Server）

处于就绪态的进程按先后顺序链入到就绪队列中，而FCFS调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。FCFS调度算法采用的是不可抢占的调度方式，一旦一个进程占有处理机，就一直运行下去，直到该进程完成其工作，或因等待某一事件而不能继续执行时，才释放处理机。

 FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。

2. 短作业优先调度算法（SJF，Short Job First）

短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

SJF又分为两种：

（1）SRTF抢占式：又称最短剩余优先，当新进来的进程的CPU区间比当前执行的进程所剩的CPU区间短，则抢占。

（2）非抢占式：称为下一个最短优先，因为在就绪队列中选择最短CPU区间的进程放在队头。

SJF调度算法的特点是吞吐率高，平均等待时间、平均周转时间最少；但算法对长作业十分不利，也完全未考虑作业的紧迫程度。

3. 时间片轮转法（RR，Round Robin）

时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。

在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。

时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。

时间片q = 系统对相应时间的要求RT / 最大进程数N

（经验表明，时间片的取值，应该使得80%的进程在时间内完成所需的一次CPU运行活动。）

4. 多级反馈队列调度算法（MLFQ，Multi-Level Feedback Queue）

设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。仅当第1～i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行。赋予各个队列中进程执行时间片的大小也各不相同。在优先级越高的队列中，每个进程的执行时间片就越小或越大（Linux-2.4内核就是采用这种方式）。

当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的末尾，按FCFS的原则排队等待调度。若轮到该进程执行且在一个时间片结束时尚未完成，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，可使用FCFS或RR调度算法来运行处于此队列中的进程。

如果处理机正在第i（i>1）队列中为某进程服务时，又有新进程进入第k（k<i）的队列，则新进程将抢占正在运行进程的处理机，即由调度程序把正在执行进程放回第i队列末尾，重新将处理机分配给处于第k队列的新进程。

5. 高响应比优先调度算法（HRRF，Highest Response Ratio First）

高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。

响应比 = （等待时间+要求服务时间） / 要求服务时间 = 响应时间 / 执行时间

6. 最高优先级优先调度算法（PR，Priority First）

在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：

 （1）非剥夺式优先级调度算法。

当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。

（2）剥夺式优先级调度算法。

当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。

## 进程同步

### 临界区与临界资源

临界区：同一时间只能允许一个进程使用的资源

临界资源：访问临界区的代码段

### 临界区调度原则

1. 一次至多一个进程能够进入临界区内执行
2. 如果已有进程在临界区，其它试图进入的进程应等待
3. 进入临界区内的进程应在有限时间内退出，以便让其它进程能够进入

### 死锁

> [wljliujuan](https://blog.csdn.net/wljliujuan/article/details/79614019)

死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的一种僵局（Deadly-Embrace) ，若无外力作用，这些进程（线程）都将无法向前推进。

**产生死锁的四个必要条件**

**互斥条件**：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

**不可剥夺条件**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。

**请求与保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。

**循环等待条件**：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。

**处理死锁方案**

由于死锁产生需要4个必要条件，因此只要破坏其中一个就能解决死锁问题

1. 破坏“互斥”条件:

就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般来说在所列的四个条件中，“互斥”条件是无法破坏的（并发问题）。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。

2. 破坏“占有并等待”条件:

破坏“占有并等待”条件，就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。

方法一：创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 “ 一次性分配”方案。

方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。

3. 破坏“不可抢占”条件：

破坏“不可抢占”条件就是允许对资源实行抢夺。

方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。

方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。

4. 破坏“循环等待”条件：

破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。

**银行家算法**

一个避免死锁的算法

操作系统按照一定规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。
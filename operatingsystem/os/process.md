> [操作系统原理](https://item.jd.com/12397357.html)

## 一、CPU三级调度

1、高级调度（作业调度）

在内存资源有限的情况下，决定哪些程序可以装入内存执行，这就是高级调度。

一个程序只会被一次高级调度

2、中级调度（内存调度）

由于内存资源有限，可以使用虚拟内存技术，把暂时不需要的进程调出（对应的PCB不会被调出，因为PCB记录了该进程的状态信息）到虚拟内存中，这些进程处于挂起状态。决定调出和调入哪些程序的过程就是中级调度。

一个进程可以被多次中级调度

3、低级调度（**进程调度**）

即如何分配CPU资源给进程。

发生频率最高

## 二、进程七态模型

![image-20201029155128631](https://gitee.com/p8t/picbed/raw/master/imgs/20201029155130.png)

其中挂起的含义为移出内存，挂起就绪和挂起等待的区别为除了内存资源是否还需要其它资源

## 三、进程控制块

PCB是描述进程的数据结构，用于操作系统为进程实体分配合适的内存、获取不同进程的不同状态信息、处理多个进程对共享内存的使用、协调进程间通信等问题。

PCB包含以下信息：

（1）进程标识符（PID）。每个进程都必须有唯一的进程标识符，也称进程的内部名。

（2）进程的当前状态。它表明进程当前所处的状态，并作为进程调度程序分配 CPU的依据，仅当进程处于就绪状态时才可以被调度执行。若进程处于阻塞状态，还需要在PCB中记录阻塞的原因，以供唤醒原语唤醒进程时使用。

（3）进程中的代码段与数据段地址。用于将 PCB 和与之对应的进程在内存或外存的代码段及数据段联系起来。

（4）进程资源清单。列出进程所拥有的除 CPU之外的资源记录，如打开的文件列表和拥有的I/O设备等。资源清单用于指出资源的需求、分配和控制信息。

（5）进程优先级。通常是一个表示进程使用 CPU优先级别的整数。进程调度程序根据优先数的大小来确定优先级的高低，并把CPU控制权交给优先级最高的就绪进程。

（6）CPU现场保护区。当进程因某种原因放弃使用 CPU时，需要将当时（执行的断点处）的 CPU各种状态信息保护起来（暂存于内存中操作系统的内核区），以便该进程再次得到CPU时，能够恢复当时的CPU各种状态，即复原当时的运行现场和环境，使得该进程可以不受影响地由断点处恢复运行。被保护的 CPU现场信息通常有程序状态字PSW、程序计数器PC的内容，以及通用寄存器的内容和用户栈指针等。

（7）进程同步与通信机制。用于实现进程之间的互斥、同步和通信所需的信号量、信箱或消息队列的指针等。

（8）PCB队列指针或链接字。用于将处于同一个状态的进程连接成一个队列，链接字中存放该进程所在队列中的下一个进程PCB的首地址。

（9）与进程相关的其他信息。如进程的家族信息、进程所属的用户、进程占用 CPU的时间以及进程记账信息等。

## 四、进程控制

### 进程上下文

除进程实体之外，进程的运行还需要其他硬件环境的支持，如程序状态字 PSW、段表、页表等数据结构。一个进程运行时，CPU所有寄存器中的内容、进程的状态以及运行栈中的内容被称为进程的上下文。进程上下文是操作系统用来管理和控制进程的内部数据集合，进程在其上下文中运行。进程上下文可分成以下三部分。

（1）系统级上下文。操作系统内核进程使用的进程上下文信息集合，主要包括 PCB与逻辑地址到物理地址转换的核心数据结构，如段表、页表及核心栈等。

（2）寄存器上下文。CPU中所有寄存器的信息集合，如通用寄存器、指令寄存器、程序状态字寄存器和栈指针等。栈指针可以是指向核心栈的指针，也可以是指向用户栈的指针。

（3）用户级上下文。用户进程访问和修改的进程上下文信息集合，主要包括进程的程序段、数据段、用户栈和共享存储区。用户级上下文占用进程的虚拟地址空间，交换到外存的分页或分段仍然是进程用户级上下文的组成部分。

当内核进行进程切换时，它需要保存当前运行进程的进程上下文，以便再次执行该进程时，能够恢复到进程被切换前的运行现场和环境而继续正常运行。发生进程切换时，新、旧进程进行上下文切换。

### 进程切换时机

进程切换是中断驱动的，引起进程切换的中断可分为以下三种。

（1）中断。中断发生时，操作系统保存当前运行进程（称为旧进程）的现场信息，调度新进程运行。

（2）异常。当 CPU在一条指令执行时，检查到有一个或多个预定义的条件或错误产生时就会产生异常，这时，终止当前运行进程的执行，CPU转去执行异常处理程序。

（3）系统调用。系统调用是对操作系统服务的一种显式请求。阻塞型系统调用发生时，则当前运行进程被阻塞，此时CPU转去执行进程调度程序。

中断发生时，操作系统暂停当前运行进程的执行，将 CPU的执行模式切换到内核态，并通过执行进程调度程序选中一个新的就绪进程准备投入运行，这时需完成新、旧进程上下文的切换。

### 进程上下文切换

进程切换发生时，当前运行进程让出其占用的 CPU，由操作系统保存当前运行进程（旧进程）的上下文环境，并设置被进程调度程序选中的就绪进程（新进程）的上下文环境，这一过程称为进程的上下文切换。

进程的上下文环境包括中断处理可能改变的所有信息，以及恢复被中断进程运行时需要的所有信息。进程切换时，操作系统将旧进程的寄存器上下文保存到核心栈的一个上下文层。当中断返回时，由操作系统内核从核心栈中恢复，为旧进程所保存的上下文。进程切换主要包括以下6个步骤。

（1）当前运行进程（旧进程）被中断时，保存其CPU现场信息。

（2）对被中断的当前运行进程进行PCB更新，包括改变进程状态和其他相关信息。

（3）将被中断的当前运行进程的 PCB移入适当的队列（因时间片到则移入进程就绪队列，因某事件发生则移入相应的进程阻塞队列）。

（4）由进程调度程序选中一个就绪进程（新进程），为其设置执行的上下文环境并对其PCB进行更新。

（5）修改新进程的地址空间，更新新进程的内存管理信息。

（6）恢复被选中的新进程最后一次进程上下文切换时所保存的CPU现场信息。

进程上下文切换时，当前运行进程（旧进程）对 CPU的控制权被回收，其状态转变为就绪态或阻塞态。

## 五、进程调度

### 调度方式

为了实现不同的 CPU调度目标，不同系统可以使用不同的进程调度方式。一般来说，进程的调整方式可分为非抢占式（非剥夺式）调度和抢占式（剥夺式）调度两类。

（1）非抢占式调度。在使用非抢占式调度方式的系统中，进程调度算法选中一个进程后就会让该进程一直运行下去，直到该进程运行结束自动释放 CPU的使用权。或者在运行过程中因发生某等待事件而阻塞时，才将 CPU的使用权返还给进程调度程序。非抢占式调度的优点是实现简单、系统开销小。但系统出现了紧急事件时不能立即处理，即实时性差。因此，非抢占式调度方式不适用于实时系统和分时系统。

（2）抢占式调度。在没有发生等待事件的情况下也允许进程调度程序暂停当前运行进程的执行，并按照某种原则将当前运行进程占用的 CPU分配给另一个更重要、更紧迫的进程使用。在这种调度方式下，被暂停运行的进程其他所需资源均已满足而只是被剥夺了CPU的使用权，故其状态应由运行状态返回到就绪状态，并将其 PCB插入到进程就绪队列。

### 调度时机

进程调度程序调度性能的优劣将直接影响 CPU 的利用率，因此什么时候运行进程调度程序是操作系统处理进程调度的关键。进程调度的原则是始终使 CPU 处于忙状态，一旦 CPU 空闲就立即进行调度。引起进程调度程序运行的时机主要有两个：一个是当前运行进程执行结束而终止，或因等待某个事件的完成而无法继续执行，这时就需要启动进程调度程序来选择一个新的就绪进程投入运行；另一个是在抢占式调度系统中，进程就绪队列中出现了优先级更高的进程，或当前运行进程的时间片已经用完，这时需要剥夺当前运行进程的 CPU 使用权，并将其分配给更高优先级的就绪进程或以时间片为单位轮转的下一个就绪进程。引起进程调度的原因主要有以下4个。

（1）创建一个新进程后。创建一个新进程后父进程和子进程都处于就绪状态，这时需要确定是父进程先运行还是子进程先运行，即可以由进程调度程序来选择。

（2）运行进程终止。运行进程正常结束时需要向系统发出一个“进程结束”的系统调用。这时进程调度程序运行，并从进程就绪队列中选择一个新的就绪进程，然后将 CPU分配给它。

（3）运行进程阻塞。当运行进程因发生了某种等待事件（如 I/O请求）或阻塞在某个信号量时，进程调度程序则调度另一个就绪进程运行。

（4）支持抢占式调度的系统中，即使没有新的就绪进程出现，为了让所有就绪进程能够轮流使用CPU，也会在下面两种情况下引起进程调度。

① 时间片到。发现当前运行进程时间片到时引起进程调度，将 CPU分配给下一个就绪进程。

② 进程的优先级发生变化。在按优先级调度的系统中，当进程优先级发生变化时引起进程调度。

现代操作系统在以下三种情况下不允许进行进程的调度和切换。

（1）中断处理过程中。由于中断处理通常不属于某一进程，因此不应作为进程的程序段而被剥夺CPU。

（2）进程在操作系统内核的临界区中。用户进程通过陷入进入操作系统内核，为实现对临界区的互斥访问，通常以加锁方式防止其他进程进入该临界区。为了加快对临界资源的释放，在该用户进程访问临界资源期间不允许切换到其他进程去执行。

（3）在需要完全屏蔽中断的原子操作执行过程中。操作系统中常用的原子操作加锁、开锁、中断现场保护和恢复等，原子操作在执行过程中不允许进行进程切换。

### 调度实现
出现进程调度后，主要完成的任务是进程切换。

（1）保存当前运行进程的现场信息。当运行进程因某种原因（如时间片到或等待I/O）需要放弃   CPU 时，进程调度程序将运行进程的 CPU 现场信息，保存到内存该进程 PCB 中的 CPU 状态保护区。

（2）选择即将运行的进程。进程调度程序根据某种调度算法从进程就绪队列中挑选一个进程，把它的状态由就绪状态改为运行状态，并准备将 CPU 分配给它。

（3）为新选中的进程恢复现场。将选中进程在内存 PCB 保存的 CPU 现场信息送入 CPU 的各寄存器，然后将 CPU 的使用权交给选中的进程，使它从上次中断运行的断点处恢复正常运行。

### 调度算法

#### 调度原则（算法评价标准）

**面向系统的准则**

从系统角度看，调度算法的选择需要满足操作系统设计目标的要求，主要有以下三方面准则。

（1）吞吐量。系统单位时间内完成工作的一种度量称为吞吐量。系统吞吐量不仅与作业的平均长度有关，还与系统采用的调度算法有关。一个好的调度算法应尽可能使单位时间内系统完成的作业数达到最多。

（2）CPU利用率。某段时间内 CPU处于忙状态时间的百分比。不同的时间段，CPU的利用率有所不同。CPU利用率是影响系统性能的一个重要指标，主要应用于低级调度，但对单用户系统或实时系统来说，该准则就显得不那么重要。CPU利用率的计算公式为

$$CPU利用率 = \frac{CPU有效工作时间}{CPU总运行时间}$$

$$CPU总运行时间 = CPU有效工作时间 + CPU空闲等待时间$$

（3）系统资源平衡利用。在一些大、中型系统中，调度策略不仅要保证系统能够获得较高的 CPU利用率，还要尽可能使系统中的其他资源都处于忙碌状态，如内存、外存和I/O设备等。

（4）公平性。在没有用户和系统提出特殊要求时，系统中的各个调度对象都应被平等对待。

**面向用户的准则**

衡量作业调度的一个标准是作业平均周转时间。作业的平均周转时间越短，则系统的效率越高、吞吐能力越强。批处理系统的调度性能除用作业周转时间衡量外，还用作业带权周转时间衡量。为满足用户要求，调度算法应遵循以下 4方面准则（下面出现的公式同样适用于进程）。

（1）周转时间。一个作业的周转时间是指该作业由提交到完成所花费的时间，即作业i周转时间为

$$T_i = 作业i完成时间 - 作业i提交时间$$

也可表示为

$$T_i = 作业i运行时间 + 作业i等待时间$$

而作业带权周转时间则为作业周转时间与作业运行时间的比值，即作业i带权周转时间为

$$W_i = \frac{作业i周转时间T_i}{作业i运行时间} = 1 + \frac{作业i等待时间}{作业i运行时间}$$

N个作业的平均周转时间是N个作业周转时间的平均值T，即作业的平均周转时间为

$$T = \frac{1}{N}\sum_{i=1}^N 作业i周转时间T_i$$

N个作业的平均带权周转时间是N个作业带权周转时间的平均值W，即作业的平均带权周转时间为

$$W = \frac{1}{N}\sum_{i=1}^N 作业i带权周转时间W_i$$

（2）响应时间。指从用户通过键盘提交一个请求开始，直到系统首次产生响应为止的时间间隔。响应时间是分时系统选择调度算法的重要准则之一，分时系统通常较少考虑周转时间。

（3）截止时间。截止时间是实时系统选择调度算法的重要准则，它可以是某实时任务（作业或进程）必须开始的最迟时间，也可以是某实时任务必须完成的最迟时间。在实时要求较高的系统中，调度算法的选择必须满足截止时间的要求。

（4）优先权准则。通过给不同的任务设定不同的优先级，并根据优先级的高低进行调度，以便让某些紧急的任务能够得到及时处理，这就是优先权准则。在某些特殊要求的系统中（如实时系统），往往还需要选择抢占式调度方式，才能保证紧急任务得到及时处理。优先权准则可以应用于批处理系统、分时系统和实时系统。

#### 常用调度算法

1、先来先服务调度算法（FCFS）

先来先服务（First Come First Service）算法是一种最简单的调度算法，可以应用于高级调度（作业调度）也可以应用于低级调度（进程调度）。高级调度时，FCFS调度算法按照作业进入后备作业队列的先后顺序选择作业进入内存，即先进入后备作业队列的作业被优先选择进入内存，然后为选中的作业创建进程并分配该作业所需资源。低级调度时，FCFS调度算法每次从内存的进程/线程就绪队列中选择一个最先进入的进程/线程，然后由进程/线程调度程序将CPU分配给它并使其运行。

FCFS调度算法是一种**非抢占式**调度算法，当某进程/线程占用了CPU后就一直运行，直到该进程/线程运行结束才放弃CPU，或在运行中因发生某等待事件被阻塞而放弃CPU。

FCFS调度算法实现简单，在等待时间上保证了一定的公平性，但也存在明显的缺陷，即没有考虑作业的类型或进程/线程执行时间的长短，使得短作业或 I/O进程/线程等待时间过长。也就是说，FCFS更适合于处理多个CPU繁忙型（计算型）的作业或进程/线程。

FCFS调度算法有利于计算型进程，而不利于占用CPU时间较短的I/O型进程。在单CPU系统中，当一个计算型进程正在占用CPU运行时，所有的I/O型进程都必须等待（因此无法启动I/O设备工作，即I/O设备得不到充分利用）。计算型进程释放CPU时，这些就绪的I/O型进程各自占用CPU短暂地运行后（仅完成启动I/O设备的工作）就可能阻塞（等待I/O操作的完成），因此插入到相应的I/O阻塞队列中等待。如果这时计算进程也阻塞了（假定系统中只有一个计算进程），就会在系统中出现没有等待执行的就绪进程而使CPU空闲，从而造成CPU得不到充分利用的极端情况出现。在使用FCFS调度算法的系统中，作业的平均周转时间与进程提交给系统的顺序有关。优先提交短进程的FCFS调度算法能够获得更好的平均周转时间。

FCFS调度方法现在已很少作为主要的调度算法单独使用，尤其是在分时系统和实时系统中，通常是与其他调度算法结合使用。如在优先级调度策略中，对优先级相同的进程则按FCFS调度方法进行调度。

2、短作业/短进程优先调度算法（SJF/SPF）

短作业优先（SJF）调度算法每次从后备作业队列中，选择估计运行时间最短的作业进入内存，并创建相应的进程。SJF调度算法也可以应用于低级调度，将 SJF应用于进程调度时，则称为短进程优先调度（SPF）。短进程优先调度算法每次从进程就绪队列中选择估计运行时间最短的进程，由进程调度程序将 CPU分配给它使其投入运行。当两个或两个以上作业/进程具有相同的估计运行时间时，SJF/SPF调度算法则按照FCFS算法进行调度。

SJF/SPF调度算法是一种**非抢占式**调度算法，某作业的进程一旦获得了 CPU，就一直运行到进程完成或因某事件阻塞而放弃CPU。所以SJF/SPF调度算法不适合分时系统或实时系统。

与 FCFS调度算法相比，SJF/SPF调度算法更加偏向短作业/短进程，使得系统在单位时间内完成的作业/进程数增加，能够获得更好的平均周转时间和平均带权周转时间。

短作业/短进程优先调度算法没有考虑长作业或运行时间较长的进程。当后备作业队列或进程就绪队列中总有短作业或短进程进入时，长作业或长进程就会因长期得不到调度而出现饥饿现象。

短作业/短进程优先调度方法能有效地降低作业/进程的平均等待时间，提高系统的吞吐量，但缺点是用户提供的估计运行时间不一定准确，此外长作业/长进程有可能长时间等待而得不到运行。

3、时间片轮转调度算法（RR）

时间片轮转（Round Robin）调度算法主要用于低级调度。在采用时间片轮转调度算法的系统中，**进程/线程就绪队列总是按进程/线程到达系统时间的先后次序进行排队，进程/线程调度程序按先来先服务的原则，选择就绪队列中的第一个进程/线程，将 CPU分配给它执行。进程/线程每次使用 CPU的时间只能是一个时间片，当运行进程/线程用完规定的时间片时必须放弃CPU的使用权。**这时，进程/线程调度程序又将CPU分配给当前就绪队列的第一个进程/线程，而放弃 CPU的进程/线程，则回到就绪队列的队尾，等待下次轮转到自己时再投入运行。所以只要是处于就绪队列中的进程/线程，按时间片轮转法调度将迟早会获得CPU而得到运行，并不会发生无限期等待的情况。

如果某个正在运行的进程/线程其时间片尚未用完，但却因发生某事件（如I/O请求）而被阻塞，这时就不能把该进程/线程返回到就绪队列的队尾，而是将其插入到相应的阻塞队列中。只有阻塞它的等待事件已经结束（完成），才能重新返回到就绪队列的队尾，等待再次被调度执行。

时间片轮转调度算法的核心是时间片。如果时间片很长，则可能大多数进程/线程都能在一个时间片内完成，这时时间片轮转调度算法实际上已退化为 FCFS调度算法；如果时间片很短，则 CPU真正用于运行用户进程/线程的时间就很少，这样会导致进程/线程频繁切换，从而使大量的 CPU时间消耗到系统处理时钟中断，以及运行进程/线程调度程序上。一个理想的时间片长短通常设计成略长于一次典型交互所需要的时间，即能够使运行进程/线程产生一个输入/输出请求。为了考虑不同类型作业的需求，还可以采用可变的时间片长短。

时间片轮转调度方式实际上是一种**基于时钟的抢占式**调度算法。在使用该调度算法的系统中，系统周期性地产生时钟中断。当时钟中断发生时，运行进程/线程使用的 CPU被剥夺，该进程/线程重新回到就绪队列的队尾。

4．高响应比优先调度算法（HRRF）

高响应比优先（Highest Response Ratio First）调度算法实际上是一种基于动态优先数的**非抢占式**调度算法，可以应用于作业调度，也可以应用于进程/线程调度。按照高响应比优先调度算法，每个作业或进程/线程都拥有一个动态优先数，该优先数不仅是作业或进程/线程运行时间（估计值）的函数，还是其等待时间的函数。高响应比优先调度算法中的优先数通常也称为响应比Rp，其定义为

$$R_p = \frac{响应时间}{运行时间} = \frac{运行时间 + 等待时间}{运行时间} = 1 + \frac{等待时间}{运行时间}$$

高响应比优先调度算法在每次调度作业/进程运行时，都要计算后备作业队列中每个作业的响应比，或者计算进程就绪队列中每个进程的响应比，然后选择最高响应比的作业/进程投入运行。当然，初始时短作业/短进程的响应比一定比长作业/长进程的响应比高，但随着等待时间的增加，长作业/长进程的响应比会随之提高，只要等待一定时间，长作业/长进程就会因成为响应比最高者而获得运行。高响应比优先调度算法在每次调度作业/进程运行时，都要计算后备作业队列中每个作业的响应比，或者计算进程就绪队列中每个进程的响应比，然后选择最高响应比的作业/进程投入运行。当然，初始时短作业/短进程的响应比一定比长作业/长进程的响应比高，但随着等待时间的增加，长作业/长进程的响应比会随之提高，只要等待一定时间，长作业/长进程就会因成为响应比最高者而获得运行。

高响应比优先调度算法既照顾了短作业/短进程，又不使长作业/长进程等待时间过长，是先来先服务调度算法和短作业/短进程优先调度算法的一种很好的折中调度方案。但缺点是需要估计每个作业或进程/线程的运行时间，而且每次调度时都要计算后备作业队列中所有作业或进程就绪队列中所有进程的响应比，这需要耗费不少的CPU时间。从平均周转时间来看，短作业/短进程优先最短，高响应比优先次之，而先来先服务最长。

5．优先级调度算法

优先级调度算法既可用于高级调度，也可用于低级调度，还可用于实时系统。若调度的对象为作业，优先级调度算法每次从后备作业队列中选择优先级最高的作业调入内存，为其分配相应的资源并创建进程放入到进程就绪队列。若调度的对象为进程，则优先级调度算法每次从进程就绪队列中，选择优先级最高的进程为其分配 CPU而投入运行。如果有多个优先级最高的作业/进程，则可结合先来先服务或短作业/短进程优先调度策略。

（1）静态优先级

作业/进程在进入系统或创建时被赋予一个优先级，该优先级一旦确定则在其整个生命期内不再改变。对于作业，其优先级可依据费用来确定；对于进程，其优先级主要依据进程的类型（系统进程还是用户进程）、进程的资源需求（资源需求少的进程优先级高）、时间需求（短进程优先）和用户要求来确定。

静态优先级的优点是比较简单，系统开销小；缺点是不够公平也不太灵活，有可能出现低优先级的作业/进程长时间得不到调度的情况。

（2）动态优先级

动态优先级在调度对象（作业/进程）刚进入系统时，也需要依据某种原则为其赋予一个优先级。但随着时间的推进，不同调度对象的优先级在不断地进行动态调整。如当进程获得某种资源时，其优先级被动态提高使其能更快地获得 CPU投入运行，以避免资源浪费。又如当进程处于就绪状态时，其优先级随着等待 CPU的时间增长而提高，而占有CPU的进程其优先级则随着使用CPU时间的增长而降低，这样来保证系统的公平性。

动态优先级的优点是公平性好、灵活、资源利用率高，既可以防止有些调度对象长期得不到调度，又可以防止有些调度对象长期占用CPU。

在采用优先级法的低级调度中，又分为**抢占式**和**非抢占式**两种调度方式。

（1）抢占式优先级调度。这种方式下具有最高优先级的就绪进程/线程首先得到 CPU运行，并在运行过程中允许被具有更高优先级的就绪进程/线程抢占 CPU。抢占式优先级调度算法能更好地满足紧迫性任务的要求，通常应用于要求比较严格的实时系统中，但会增加系统中进程/线程切换的开销。

（2）非抢占式优先级调度。某个就绪进程/线程一旦获得 CPU就会一直运行下去，直到该进程/线程完成或因某等待事件发生而阻塞，才放弃 CPU的使用权。非抢占式优先级调度算法通常用于批处理系统中。

6．多级反馈队列调度算法（MLFQ）

前面介绍的各种低级调度算法或多或少都存在一定的局限性。先来先服务调度算法倾向于长进程，因此会使得短进程的等待时间过长；短进程优先调度算法和高响应比优先调度算法，要事先估计各进程大致的运行时间，否则将无法完成调度。多级反馈队列（Multi-Level Feedback Queue）调度算法考虑了这些因素，并**对时间片轮转调度算法和优先级调度算法进行了综合和改进**，形成了这种**基于时间片抢占式动态优先级调度算法**。

多级反馈队列调度算法为就绪状态的进程设置多个队列，第1级队列的优先级最高但时间片最少，以下各级队列的优先级逐次降低但时间片却逐次增加，通常向下一级其时间片增加一倍。各级队列均按先来先服务（FCFS）原则排序。多级反馈队列调度示意如下图所示（省略了进程运行中发生等待事件的情况）。

![image-20201029181823179](https://gitee.com/p8t/picbed/raw/master/imgs/20201029181824.png)

多级反馈队列的调度方法主要有以下三种。

（1）设置多个进程就绪队列，每个进程就绪队列对应一个优先级，且按队列逐级降低，就绪队列 Q1的优先级最高。每个队列执行的时间片长度也不同，原则是优先级越低则时间片越长。

（2）新进程（就绪状态）进入内存后，先放入进程就绪队列 Q1的队尾。运行按时间片轮转法（RR）调度，若按队列Q1设置的时间片未能运行完，则下放到进程就绪队列Q2的队尾，队列Q2同样按时间片轮转法调度。如此下去，最终可降至Qn队列，Qn队列可按时间片轮转算法或先来先服务算法进行调度，直到完成。

（3）仅当前面较高优先级的队列均为空时，才能调度后面较低优先级队列中的进程运行。如果进程运行中有新进程进入更高优先级的队列，则新进程将抢占 CPU，被抢占CPU的进程则回到原队列的队尾。

多级反馈队列调度算法的主要优点是：① 短进程能够得到优先处理，因为短进程通常在优先级较高的几个队列中即被执行完毕；② 系统开销不大，因为运行时间长的进程主要将在优先级较低的队列中运行，由于这些队列的时间片较长，因此引起进程的切换就相对较少，也即开销较小；③ 对分时系统来说，用户提交的大多是 I/O型进程/线程，而多级反馈队列第一级队列的时间片设计应为略长于大多数I/O进程/线程产生一个I/O请求所需的时间，即交互型请求通常能够在第一个进程就绪队列中完成。所以多级反馈队列算法适用于同时支持分时、实时和批处理的通用操作系统。

多级反馈队列调度算法的主要缺点是：如果优先级较高的队列一直不为空，则优先级较低队列中的进程可能长时间得不到运行，即会导致饥饿的发生。

## 六、进程同步

### 基本概念

#### 进程的互斥与同步

（1）进程同步。进程间的同步是指某些进程之间在逻辑上的相互制约关系。也就是说，若干进程为完成一个共同的任务而相互合作，由于合作的每个进程都是以各自独立的、不可预知的速度向前推进，这就需要相互合作的进程在某些协调点处来协调它们的工作。当一个合作进程到达此协调点后，在未得到其他合作进程发来的消息之前则阻塞自己，直到其他合作进程给出协调信号后，才被唤醒再继续执行。进程之间这种相互合作等待对方消息的协调关系就称为进程同步。

（2）进程互斥。进程互斥是指某一资源同一时间只允许一个进程对其进行访问，这种访问具有唯一性和排他性。进程互斥通常是进程之间争夺互斥资源而引起的，在这种情况下，任何时刻都不允许两个及两个以上的并发进程同时执行那段访问该互斥资源的程序代码。

互斥的实现还会产生两个额外的控制问题：饥饿（Starvation）和死锁（Deadlock）。

（1）饥饿。一个进程所申请的资源总是被优先于自己的其他进程所占有，而长时间处于不能被调度执行的状态（长时间处于就绪或阻塞状态），将这种现象称为“饥饿”。例如，系统中有三个周期性执行的进程：P1、P2和P3，其中P1正在占用CPU执行，而P2和P3处于就绪状态。如果三个进程对CPU竞争的结果是P1释放CPU后，将其分配给P2运行，而P2释放CPU后又将其分配给P1再次运行，如此循环往复，这就使得处于就绪状态的进程P3长时间不能被调度执行，这就是饥饿状态。

（2）死锁。一个进程集合中已经占有部分资源的两个或两个以上进程，还需要获得已被其他进程占有的资源才能够继续执行，有可能出现某些进程相互之间都在等待对方占有的资源而无法运行的局面，即在进程集合中的这些进程处于永远的阻塞状态，这就是“死锁”。例如，有两个进程P1和P2在执行过程中都需要使用互斥资源R1和R2，且资源R1和R2均只有一个。假设在某时刻P1占用了R1又要申请使用R2，而P2占用了R2又要申请使用 R1，这时 P1因申请已被P2占用的 R2而阻塞，P2则因为申请已被 P1占用的R1而阻塞，从而出现P1和P2因相互等待对方资源而始终无法运行的死锁状态。

进程同步与进程互斥的相似之处是进程互斥实际上是进程同步的一种特殊情况，即逐次使用互斥资源，这也是对进程使用资源次序的一种协调（同步）。因此可以将进程互斥和进程同步统称为进程同步。

进程同步与进程互斥的区别是进程互斥是由互斥资源引起的，即各进程之间共享互斥资源的使用权。这种竞争没有确定的必然联系，哪个进程竞争到互斥资源的使用权，则该资源就归哪个进程使用，而获得所需资源的进程就可以获得 CPU继续执行，直到它不再需要该资源时才放弃该资源的使用权，而那些未申请到互斥资源的进程则不能执行，直到得到所申请的互斥资源。也就是说，进程互斥是通过互斥资源来制约各进程执行的，这种互斥无法限制进程对资源的访问顺序，即访问是无序的。进程同步则是指相互协作的并发进程之间存在着必然的联系，若当前运行进程执行过程中需要进行同步时，在没有得到协同工作的其他合作进程发来的同步消息之前，当前运行进程则不能继续向前推进（运行）。在进程同步中，虽然互斥资源仍然制约着进程的执行，但协调各进程向前推进的只能是进程同步，即通过进程同步来协调和制约各合作进程的执行，去完成一个共同的任务，即进程同步是在互斥的基础上（大多数情况），通过其他机制实现进程对资源的有序访问。

#### 临界资源与临界区

临界资源：同一时间只能允许一个进程使用的资源

临界区：访问临界资源的代码段

#### 临界区调度原则

（1）空闲让进。无进程处于临界区时意味着临界资源处于空闲状态，这时若有进程要求进入临界区应立即允许进入。

（2）忙则等待。当已有进程进入其临界区时则意味着某临界资源正在使用，所有其他欲访问该临界资源的进程，试图进入各自临界区时必须等待，以保证各进程互斥地进入访问同一个临界资源的临界区。

（3）有限等待。若干进程要求进入访问同一个临界资源的临界区时，应在有限时间内使一个进程进入临界区，即不应出现各进程相互等待而都无法进入临界区的情况。

（4）让权等待。当进程不能进入其临界区时，应立即释放所占有的 CPU，以免陷入“忙等”（进程在占有CPU的同时又一直等待），保证其他可执行的进程获得CPU运行。

### 进程同步与互斥实现

**硬件方法**

1、开关中断指令

开关中断指令又称为硬件锁，使用它来实现进程互斥最简单。具体方法是进程在进入临界区之前，先执行“关中断”指令来屏蔽掉所有中断，进程完成临界区的任务后，再执行“开中断”指令将中断打开。由于单 CPU系统中的进程只能交替执行，因此一旦在进入临界区之前屏蔽掉所有中断，计算机系统就不再响应中断，因此也就不能调度其他进程运行。这样，进程在进入临界区后就一直占用CPU，而其他进程则因中断被屏蔽也无法被调度执行，故不能进入临界区。

使用开关中断的指令实现进程互斥只适合单CPU系统，且存在以下缺点：如果关中断的时间过长，会使系统效率下降，若关中断不当，有可能导致系统无法正常调度进程运行。

2、测试与设置指令TS（Test and Set）

采用TS方法则要为每个临界资源设置一个整型变量s，可以将它看成一把锁。若s的值为 0（开锁状态），则表示没有进程访问该锁对应的临界资源；若 s的值为 1（关锁状态），则表示该锁对应的临界资源已被某个进程占用。

使用TS指令存在以下缺点：当一个进程还在访问临界区时，其他欲进入临界区的进程，只能不断地循环测试 s的值，显然，不断循环测试s造成了CPU浪费，这就是“忙等”。也就是说，这种方式没有遵循“让权等待”的原则。

3、CAS

对应汇编指令`LOCK CMPXCHG`

**信号量**

在操作系统中，信号量代表了一类物理资源，它是相应物理资源的抽象。具体实现时，信号量被定义成具有某种类型的变量，通常为整型或结构体类型，即信号量可分为整型信号量和结构体信号量。信号量除初始化外，在其他情况下其值只能由P和V两个原语操作才能改变。

**管程**

信号量机制虽然是一种有效的进程互斥与同步机制，但实现进程同步的 P 操作和 V 操作可能分布在整个程序中，这不仅给编程和进程管理带来麻烦，而且P操作执行次序的不当也可能会导致死锁。为了解决信号量机制带来的不便而引入了管程同步机制。

通过管程机制把将分散在各进程中的同步操作集中起来统一控制和管理，进程通过调用管程中的过程或函数可以更方便地实现进程的互斥与同步（包括对临界资源的互斥使用），同时也可以减少错误的发生。

## 七、进程通信

同步与通信是并发进程交互的两个基本要求。进程同步主要解决临界区问题，而进程通信主要指进程之间的信息交换。虽然信号量机制解决了进程的互斥与同步问题，但没有解决如何在进程之间传递大量信息的问题。

**进程通信方式**

### 1、共享内存

共享内存通信方式是指在内存中划出一块内存区作为共享数据区，称为共享内存分区，要通信的进程双方将自己的虚拟地址空间映射到共享内存分区上。通信时，发送进程将需要交换的信息写入该共享内存分区中，接收进程从该共享内存分区中读取信息，从而实现进程之间的通信。由于共享内存通信方式不要求数据移动两个需要交换信息的进程，通过对同一个共享数据区进行写入和读出操作，来达到相互通信的目的，而这个共享数据区实际上是每个相互通信进程的一个组成部分，因此它是进程之间最快捷、最有效的一种通信方式。

### 2、消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 3、信号量

计数器，控制多个进程对共享资源的访问

### 4、管道

管道是指连接在两个进程之间的一个打开的**共享文件**，也称为pipe文件，专门用于进程之间进行数据通信。发送进程可以从管道一端写入数据流；接收进程可以从管道的另一端读出数据。

管道与一般文件相比又有些特殊，主要体现在以下三个方面。

（1）管道专门用于通信。

（2）管道只能单向传送数据。

（3）在对管道进行读写操作过程中，发送者进程和接收者进程所需要的同步与互斥都由系统自动进行，即对用户是透明的。

管道最早出现在UNIX中，分为匿名管道和命名管道。

（1）匿名管道

在早期的UNIX版本中只提供了匿名管道，匿名管道是利用系统调用pipe建立起来的无路径名的无名文件，并且是一个临时文件。使用匿名管道通信时，是通过使用临时文件的方式来实现进程之间的批量数据传输。当通信进程不再需要此匿名管道时，由系统关闭并回收与它相关联的索引节点。由于匿名管道是一个临时文件，当该临时文件被关闭后，匿名管道就不再存在。

由于匿名管道是一个临时文件，它只能用系统调用pipe所返回的文件描述符来标识。因此只有调用pipe的进程及其子孙进程才能识别此文件描述符，并利用该匿名管道进行通信。所以通过匿名管道通信的所有进程必须是父子关系，或者是祖先进程和子孙进程的关系，若通信双方不满足同一家族这个条件，则不能建立直接通信联系。

此外要说明的是，通过文件系统看不到匿名管道的存在（即对用户透明）。一般文件在使用前需要用系统调用open打开，而匿名管道建立后就可以直接使用（写和读）。

（2）命名管道（FIFO）

为了克服匿名管道在使用上的不足，UNIX系统中增加了命名管道，它可以实现无家族关系进程之间的通信。

与匿名管道是一个临时文件不同，命名管道被建立后在磁盘上有一个对应的目录项和索引节点。也就是说，命名管道是具有路径名并可在文件系统中长期存在的真实文件，它不能与文件系统中的任何文件重名，并且在文件系统中也可以看到该命名管道。此外，对命名管道的访问也与一般文件一样，需要先用系统调用open打开。

由于命名管道是一个真实文件，因此其他进程可以感知它的存在，并能利用其路径名来访问该命名管道实现进程之间的通信。命名管道不仅可用于进程之间的本地通信，而且可用于网络环境下的不同计算机之间的进程通信。

命名管道虽然可以实现无家族关系进程之间的通信，但通信的双方只能是单方向的。由于通信只与管道直接联系，因此进程之间不知道通信的对方是谁，也不能对发来的数据进行选择性地接收。

管道通信的基础是文件系统，所以管道的创建、打开、读写及关闭等操作都借助于文件系统的原有机制来实现，而发送进程和接收进程使用管道的方式则通过引入通信协调机制来解决。在对管道文件进行读写操作过程中，发送进程和接收进程需要按照以下方式实施正确的互斥与同步，以确保通信的正确性。

（1）当一个进程正在对管道进行读写操作时，其他进程必须等待（阻塞）。

**（2）当发送进程将一定数量的数据写入管道后就阻塞自己，直到管道中的数据被接收进程取走后再由接收进程将它唤醒。而接收进程在接收数据时，若管道为空则阻塞自己，直到发送进程将数据写入管道后再由发送进程将它唤醒。**

此外在使用管道通信时，发送进程和接收进程还必须以某种方式来确定对方的存在，只有双方存在才有通信的必要。

管道通信的优点是传送数据量大，并且管道通信机制中的互斥与同步都由操作系统自动进行（对用户透明），因此使用方便；缺点是通信速度较慢（命名管道实际上是一个磁盘文件，因此通信中的数据传送需要启动外部设备）。

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

![image-20201103093526954](https://gitee.com/p8t/picbed/raw/master/imgs/20201103093528.png)

### 5、Socket

用于网络进程通信，通过IP+端口号唯一标识网络上的进程

## 八、死锁

### 产生死锁的四个必要条件

（1）互斥条件。进程对所获得的资源进行排他性使用，任一时刻一个资源仅被一个进程占用。

（2）不可剥夺条件。进程所获得的资源在未使用完毕之前不能被其他进程抢占，而只能由占用该资源的进程自己释放。

（3）请求和保持条件。一个进程请求资源得不到满足而阻塞自己时，并不释放已分配给它的资源，该条件也称为部分分配条件。

（4）循环等待条件。若干进程（两个或两个以上）形成一个循环等待链，链中每个进程都在等待该链中下一个进程所占用的资源。

### 死锁的预防

根据死锁的4个必要条件，只要设法破坏4个必要条件中任意一个，死锁就不会发生。这种通过破坏死锁的必要条件来控制死锁的策略称为死锁预防（Deadlock Prevention）。但破坏必要条件（1）显然不行，这是因为进行互斥访问是由不可抢占资源的固有特性决定的，因此要预防死锁发生可以设置限制条件，使请求和保持、不可抢占、循环等待这3个必要条件中的某一个不成立。

1、破坏“不可剥夺”条件

要破坏“不可剥夺”条件，可以采用抢占资源分配策略，即进程在运行过程中根据需要逐个提出资源请求，当一个已经占有了某些资源的进程，且又提出新的资源请求而未得到满足时，则必须释放它已获得的全部资源而进入阻塞状态，待以后需要时再重新申请。由于进程在阻塞时已释放了它所占用的全部资源，于是可以认为该进程所占用的资源被抢占了，从而破坏了不可抢占条件。

这种方法可以预防死锁的发生，但其缺点是致命的：① 有些资源被抢占后很可能会引起错误，这是因为一个资源在使用一段时间后又被强行抢占，有可能造成前一段时间的工作失败，即使采取一些补救措施也有可能使前后两次的执行结果不连续。例如，某进程在使用打印机输出一些信息后，因申请其他资源没有成功而被阻塞时放弃了打印机，这时该打印机被分配给其他进程使用输出信息，当该进程重新运行又获得该打印机输出时，就会造成前后两次的打印结果不连续；② 该方法实现起来比较复杂且代价太大，进程的反复申请和释放资源会使进程推进缓慢，甚至可能导致进程的执行被无限推迟，这不但延长了系统的周转时间，而且也增加了系统的开销；③ 可能存在某些进程的资源总是被抢占而造成的“饥饿”。

2、破坏“请求和保持”条件

要破坏“请求和保持”条件，可以采用资源预分配策略：每个进程在运行之前一次性申请它所需要的全部资源，并在资源未得到满足之前不投入运行。进程一旦投入运行，则分配给它的资源就一直归该进程所有，且不再提出新的资源请求。这种分配方法使请求条件不成立，并且只要系统有一种资源不能满足进程的要求，即使其他资源空闲也不将空闲资源分配给该进程，而使该进程阻塞。由于进程阻塞时没有占用任何资源，因此保持条件也不成立。

这种方法的优点是安全、简单且易于实现。缺点是：① 系统资源严重浪费，这是因为尽管进程一次性获得了所需的全部资源，但这些资源可能分别只在进程运行的某一时段内使用，在不使用的那段时间内这些资源被浪费了；② 由于进程只有获得了全部资源后才能运行，因此会导致一些进程长时间得不到运行；③ 很多进程在运行之前，系统并不能确切地知道它到底需要多少资源。

3、破坏“循环等待”条件

要破坏“循环等待”条件，可以采用资源有序分配策略，即将系统中所有资源进行编号，并规定进程申请资源时必须严格按照资源编号递增（或递减）的顺序进行。如将输入机、磁带机、打印机和磁盘分别编号为 1、2、3和 4。若采用资源有序分配策略，进程在获得某个资源后，下一次只能申请较高（或较低）编号的资源，不能再申请低（或高）编号的资源。于是任何时候在申请资源的一组进程中，总会有一个进程占用着具有较高（或较低）编号的资源，它继续申请的资源必然是空闲的，以至于在对应的资源分配图上，不可能形成进程-资源循环等待环路，从而破坏了循环等待条件。

这种预防死锁策略与前两种策略相比，系统的资源利用率和吞吐量有明显改善，但也存在以下不足：① 进程实际使用资源的顺序不一定与编号顺序一致，资源有序分配策略会造成资源浪费；② 资源不同的编号方法对资源的利用率有重要影响，且很难找到最优的编号方法；③ 资源的编号必须相对稳定，当系统添加新种类设备后处理起来比较麻烦；④ 严格的资源分配顺序使用户编程的自主性受到限制。

资源有序分配策略的一种改进是层次分配策略，即将系统中资源划分为若干个层次，一个进程获得某层次的资源后，其后只能申请该层或较高层次的资源。如果申请同层的另一个资源，则必须先释放它占用的同层资源。当进程要释放属于某个层次的资源时，必须先释放它占用的所有较高层次的资源。

### 死锁的避免

前面讨论的几种预防死锁方法尽管实现起来较为简单，但基本上都严重影响了系统的性能或可能引起致命的错误。严重影响系统性能主要是对资源分配策略施加了比较严格的限制条件，如一次性分配所需资源和有序分配资源。可能引起致命错误则是对资源性质做了不恰当的修改，如将不可抢占改为可抢占、保持改为不保持等。

与死锁的预防相比，死锁的避免（DeadLock Avoidance）是在不改变资源固有性质的前提下，对资源的分配策略施加较少的限制条件来避免死锁的发生。或者说，死锁的预防需要破坏死锁的4个必要条件之一，而死锁的避免则无须刻意破坏死锁的4个必要条件，只是对资源的分配策略施加了少许的限制条件来避免死锁的发生。

由于施加的限制条件较少，死锁的避免与死锁的预防相比，能够获得较为满意的系统性能。但是死锁的避免是建立在一个假设的前提基础上，即每个进程对自己使用的资源总需求必须清楚。也就是说每个进程必须事先声明自己需要哪些资源以及需要多少资源。这也限制了该方法的应用，或者说该方法更适用于对进程需求资源能够提前获知的这类系统。

死锁的避免对资源的分配策略施加了较少限制条件，即对资源的申请和分配策略基本不做改变，只是在每次分配资源时进行例行检查，然后根据检查的结果决定是否分配资源。也就是说允许进程动态地申请资源，若不满足则该进程被阻塞；若满足则进行动态检查。检查的过程是先假定把资源分配给该进程，然后看此次资源分配是否会使系统进入不安全状态，若检查结果是安全的，才真正分配资源给该进程；若检查结果是不安全的，则取消此次资源分配并使该进程进入阻塞状态。可见，死锁的避免就是在动态检查前提下动态地分配资源，通过检查来阻止会导致进程进入死锁状态的资源分配，从而避免死锁的发生。

**银行家算法**

操作系统按照一定规则为进程分配资源

- 当进程**首次申请资源**时，要测试该进程对资源的**最大需求量**，如果系统**现存的资源**可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。
- 当进程在**执行中继续申请资源**时，先测试该进程本次申请的资源数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足则按当前的申请量分配资源，否则也要推迟分配。

这样就能保证至少有一个进程能完成任务并释放资源，然后递归下去。

### 死锁的检测与解除

#### 死锁检测

资源分配图

#### 死锁解除

一旦发现系统出现了死锁，就必须采取某种方法来解除死锁（Deadlock Recovery），常用解除死锁的方法有以下4种。

（1）撤销所有死锁进程。这是操作系统最常用的死锁解除方法，也是复杂度最低的一种死锁解除方法。当检测到死锁进程时，直接撤销该进程并释放其占有的系统资源。

（2）让死锁进程回撤到正常执行状态的某个检查点，然后重新启动所有的进程。这种方法需要操作系统支持进程的回撤和重启，并且死锁仍可能再次发生。

（3）按照某种顺序逐个撤销死锁进程，直到不再发生死锁为止。死锁进程撤销的顺序通常是基于某种代价最小的原则，而且每撤销一个进程后必须重新执行死锁检测算法。

（4）采用抢占资源的策略直到不再发生死锁。这种方式也需要按照某种代价最小的原则进行资源抢占，而且每次抢占资源后也需要重新执行死锁检测算法，以测试系统是否仍存在死锁，这种方法实现的复杂度最高。

死锁解除中的代价最小原则有以下5个。

（1）到死锁发现时，消耗的CPU时间最少。

（2）到死锁发现时，获得系统资源的总量最少。

（3）到死锁发现时，产生的输出量最少。

（4）优先级最低。

（5）预计进程的剩余时间最长。

死锁检测算法会消耗很多的 CPU时间，在实际系统中允许进行人工干预。尽管检测和解除死锁系统要付出较大的代价，但由于死锁并不经常发生，因此付出这样的代价是值得的。
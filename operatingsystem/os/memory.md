> [操作系统原理](https://item.jd.com/12397357.html)

## 一、程序的链接和装入

### 逻辑地址和物理地址

（1）逻辑地址。用户源程序经编译、链接后得到可装入程序。由于无法预先知道程序装入内存的具体位置，因此不可能在程序中直接使用内存地址，只能暂定程序的起始地址为 0。这样，程序中指令和数据的地址都是相对 0这个起始地址进行计算的，按照这种方法确定的地址称为逻辑地址或相对地址。一般情况下，目标模块（程序）和装入模块（程序）中的地址都是逻辑地址。

（2）逻辑地址空间。一个目标模块（程序）或装入模块（程序）的所有逻辑地址的集合，称为逻辑地址空间或相对地址空间。

（3）物理地址。内存中实际存储单元的地址称为物理地址，物理地址也称为绝对地址或内存地址。为了使程序装入内存后能够正常运行，就必须将程序代码中的逻辑地址转换为物理地址，这个转换操作称为地址转换。

（4）物理地址空间。内存中全部存储单元的物理地址集合称为物理地址空间、绝对地址空间或内存地址空间。由于每个内存单元都有唯一的内存地址编号，因此物理地址空间是一个一维的线性空间。要使装入内存的程序后能够正常运行、互不干扰，就必须将不同程序装入到内存空间的不同区域。

（5）虚拟地址空间。CPU支持的地址范围一般远大于机器实际内存的大小，对于多出来的那部分地址（没有对应的实际内存）程序仍然可能使用，我们将程序能够使用的整个地址范围称为虚拟地址空间。如Windows XP采用32位地址结构，每个用户进程的虚拟地址空间为 4GB（$$2^{32}$$），但可能实际内存只有 2GB。虚拟地址空间中的某个地址称为虚拟地址，而用户进程的虚拟地址就是前面所说的逻辑地址。

### 程序链接

源程序经过编译后所得到的目标模块，必须由链接程序将其链接成一个完整的可装入模块后，才能装入内存运行。链接程序在将几个目标模块装配成一个装入模块时，需要解决以下问题。

（1）修改模块的相对地址。编译程序产生的各个目标模块中的地址都是相对地址，其起始地址都是 0。在将它们链成一个装入模块后，由于各模块不能放入同一段逻辑地址空间，故一些目标模块在装入模块中的起始地址不可能再是 0（只能有一个模块的起始地址为0），因此要根据实际情况对模块中的相对地址进行修改。如应将下图中模块B的所有相对地址都加上k（k为模块A的长度）。

（2）转换外部调用符号。在将目标模块装配成可装入模块时，应将原目标模块中的外部符号转变为相对地址。如应将模块 A中的调用模块 B（外部符号B）语句（CALL B）改为无条件转移到相对地址k语句（JMP K），如下图所示。

![image-20201030183336715](https://gitee.com/p8t/picbed/raw/master/imgs/20201030183338.png)

对于目标模块的链接，可以根据链接时间的不同分为以下三种不同的链接方式。

（1）静态链接。程序运行前把源程序编译成的所有目标模块及所需要的库函数链接成一个统一的装入模块，以后不再分开。

（2）装入时动态链接。目标模块的链接是在模块装入内存时进行的，即在模块装入过程中同时完成所有目标模块的链接。

（3）运行时动态链接。将一个目标模块装入内存后就启动运行该目标模块进程，在进程运行过程中如果需要调用其他模块，则将所需调用的模块装入内存并链接到调用模块上，然后进程继续运行。

上述三种链接方式中，使用较多的是运行时动态链接，这是因为它使某些模块的链接推迟到运行时才进行，这样凡是程序执行过程中未用到的模块都不会装入内存，因此也不会链接到运行模块上。显然，这种链接方式不仅可以节省内存空间，而且加快了程序目标模块的装入过程。

### 程序装入

源程序经过编译、链接后形成可装入模块，将它装入内存后就可以投入运行。由于程序的逻辑地址空间和内存的物理地址空间并不一致，因此装入程序在将程序（可装入模块）装入内存后，在程序执行之前还必须将程序代码中的逻辑地址转换为真实的物理地址，即进行地址转换。

1、程序装入

程序装入是指装入程序根据内存当前的实际使用情况，将程序（可装入模块）装入到内存合适的物理位置。装入操作针对的是程序（可装入模块）的整个逻辑地址空间，而对应的物理地址空间既可以是连续的，也可以是离散的。程序装入内存后并不能立即运行，因为程序中凡涉及访问内存地址（简称访存地址）的指令其访存地址仍然是逻辑地址，而不是内存中的实际物理地址，因此无法实现直接访问。要使装入内存的程序能够运行，就必须将程序中出现的逻辑地址都转换为计算机能够直接寻址的内存物理地址。这种地址转换操作称为地址映射、地址转换或地址重定位。

根据装入时间的不同，可以将程序装入分为运行前静态装入和运行时动态装入两种。静态装入指在运行之前，一次性地将全部程序（所有可装入模块）装入内存，并且在程序装入内存时或在程序运行前，一次性完成程序中所有的逻辑地址到物理地址的转换工作；运行时动态装入是指将程序的各目标模块按运行的需要，逐次调入内存并链接到调用模块上。由于是逐次装入内存，因此不可能一次性完成将程序中所有逻辑地址转换为物理地址的工作，这个地址转换工作只能推迟到程序执行中进行，即执行到涉及访存地址的指令时再进行地址转换。

2、静态重定位

静态重定位（静态地址转换）是指装入程序将全部程序（所有可装入模块）装入到内存适当的位置后，在该程序装入内存时或运行之前，一次性地将程序中凡涉及访存地址的指令其访存地址按下面的公式全部由相对地址（逻辑地址）转换为绝对地址（物理地址），并在程序运行过程中不再改变。

绝对地址=相对地址+程序存放的内存起始地址

若采用静态重定位，通常不允许在程序静态重定位后，重新移动该程序代码和数据在内存的存放位置，因为这种移动意味着刚才对程序进行的重定位必须推倒重来，即需按程序新的内存起始地址对程序再次进行静态重定位，这无疑会耗费大量的 CPU时间。静态重定位的地址转换示例如下图所示。

![image-20201030185529581](https://gitee.com/p8t/picbed/raw/master/imgs/20201030185530.png)

采用静态重定位的优点是简单、容易实现，不需要增加任何硬件设备，可以通过软件全部实现。但缺点也很明显，主要表现在以下三个方面。

（1）程序装入内存后，在运行期间不允许该程序代码和数据在内存中移动，即无法实现内存重新分配，因此内存的利用率不高。

（2）如果内存提供的物理存储空间无法满足当前程序代码和数据的存储容量，则必须由用户在程序设计时，采用某种方法来解决存储空间不足的问题，这无疑增加了用户的负担。

（3）不利于用户共享存放在内存中的同一个程序。如果几个用户要使用同一个程序，就必须在各自的内存空间中存放该程序的副本，这无疑浪费了内存资源。

3、动态重定位

动态重定位（动态地址转换）是指无论将程序一次性装入内存，还是在程序运行中动态装入各目标模块（或虚拟存储器中动态装入程序的分页和分段）到内存，都不立即进行逻辑地址到物理地址的转换，地址的转换工作是在程序执行中进行的，即当执行的指令涉及访存地址（此时为逻辑地址）时再进行地址转换。这样，那些虽然涉及访存地址但却没有执行的指令，或者没有调入内存执行的目标模块都不进行地址转换，这无疑减少了地址转换的工作量。

为了提高地址转换的速度，动态重定位要依靠**硬件地址转换机构**来完成。硬件地址转换（重定位）机构需要一个（或多个）基地址寄存器（简称基址寄存器或 BR，又称重定位寄存器）和一个（或多个）程序逻辑地址寄存器（VR）。指令或数据在内存中的绝对地址与逻辑地址的关系为

$$绝对地址 = (BR) + (VR)$$

其中，（BR）与（VR）分别表示基址寄存器和程序逻辑地址寄存器中的内容。

动态重定位的过程是：装入程序将程序（可装入模块）装入到内存，然后将程序所装入的内存区域首地址作为基地址送入 BR中。在程序运行过程中，当某条指令访问到一个相对地址（逻辑地址）时，则将该相对地址送入 VR中。这时，硬件地址转换机构把 BR和VR中的内容相加就形成了要访问的绝对地址（内存物理地址），如下图所示。

![image-20201030190706769](https://gitee.com/p8t/picbed/raw/master/imgs/20201030190707.png)

动态重定位具有以下三个优点。

（1）指令和数据的物理地址是在程序运行过程中由硬件动态形成的。只要将进程的各程序段在内存区中的起始地址存放到基址寄存器 BR中，就能由地址转换机构得到正确的物理地址。因此可以给同一进程的不同程序段分配不连续的内存区域，并且在程序装入内存后，也可再次移动该程序代码和数据在内存中的存放位置，只要将移动后该程序代码和数据在内存的起始地址放入基址寄存器 BR即可正常运行，这有利于内存的管理和内存利用率的提高。

（2）动态重定位的地址转换工作是在程序执行过程中，所执行的指令涉及访存地址时才进行地址转换，因此在程序运行时没有必要将它的所有模块都装入内存，可以在程序运行期间通过请求调入方式来装入所需要的模块，不需要的模块则不装入内存，按照这种方式使用内存就可以使有限的内存运行更大或更多的程序。因此动态重定位构成了虚拟存储器的基础。

（3）动态重定位有利于程序段的共享。多个进程可以共享位于内存区中的同一程序段，只要将该程序段在内存的起始地址放入基址寄存器BR即可。

动态重定位的缺点主要表现在两个方面：一是需要硬件支持；二是实现存储管理的软件算法比较复杂。

注意，静态重定位仅适用全部程序一次性装入内存的情况，且地址变换是在程序装入内存时或程序运行前一次性完成；动态重定位既适用全部程序一次性装入内存的情况，又适用于在程序运行中动态装入各目标模块到内存的情况，无论采用哪种装入方式，动态重定位的地址变换都是在程序运行过程中执行到涉及访存地址的指令时进行。所以一次性将全部程序装入内存的方式，可以采用静态重定位或动态重定位方式进行地址变换，但运行时动态装入程序的各目标模块到内存的方式，以及虚拟存储器中动态装入分页和分段到内存的方式，只能采用动态重定位方式进行地址变换。

## 二、程序的局部性原理

空间上：如果某个存储单元被访问，则不久以后该存储单元以及与该存储单元相邻的那些存储单元也最有可能被访问，即程序在一段时间内所访问的地址可能集中在一定的范围内。

时间上：如果程序中某条指令一旦执行，则不久的将来该指令可能会再次执行。产生时间局部性的典型原因是在程序中存在着大量的循环操作。

## 三、分区式存储管理

分区式存储管理对内存采用连续分配方式，即根据用户程序的需求为其在内存分配一段连续的存储空间。分区式存储管理属于最简单的内存管理方式，主要用于早期的操作系统。分区式存储管理又可以进一步划分为单一连续分区存储管理，固定分区存储管理和可变分区存储管理等内存管理方式。

### 1、单一连续分区存储管理

单一连续分区存储管理方式只适合于单用户、单任务操作系统，是一种最简单的存储管理方式。单一连续分区管理将内存空间划分为系统区和用户区两部分。系统区仅供操作系统使用，通常放在内存的低地址部分，系统区以外的全部内存空间就是用户区，提供给用户使用。装入程序从用户区的低地址开始装入用户程序，且只能装入一个程序运行，用户区装入一个程序后，内存中剩余的区域则无法再利用。

### 2、固定分区存储管理

固定分区存储管理是最早使用的一种可运行多道程序的存储管理方法，即将内存系统区之外的用户空间划分成若干个固定大小的区域，每个区域称为一个分区并可装入一个用户程序运行。分区一旦划分完成，就在系统的整个运行期间保持不变。由于每个分区允许装入一道程序运行，这就意味着系统允许在内存中同时装入多道程序并发执行。

### 3、可变分区存储管理

可变分区（又称动态分区）存储管理方式在程序装入内存之前并不预先建立分区，而是在程序运行时根据程序对内存空间的需要，动态的建立内存分区。分区的划分时间、大小及其位置都是动态的，因此这种管理方式又称为动态分区分配。由于分区的大小完全按程序装入到内存的实际大小来确定，且分区的数目也可变化，因此这种分配方式能够有效减少固定分区方式中出现的内存空间浪费现象，有利于多道程序设计并进一步提高内存资源的利用率。

### 4、覆盖与交换技术

存储管理的一个重要功能就是实现内存容量的扩充。在多道程序环境下，如果程序的大小超过内存可用空间时，操作系统则采用相应技术，即只将当前需要运行的部分程序和数据装入内存，而将暂时不需要运行的那部分程序和数据放入外存，当运行到需要外存上的这部分程序和数据时，再由操作系统负责将其交换到内存。采用这种方式可以解决大程序在较小内存空间中运行的问题，从而实现在逻辑上对内存容量的扩充。覆盖技术和交换技术就是两种典型的扩充内存技术，其中**覆盖技术主要用在早期操作系统中的单一连续区管理**，而交换技术在现代操作系统（多道程序环境下）中仍然占据重要的地位。

（1）覆盖技术

单 CPU系统中的任一时刻只能执行一条指令，而一个用户程序通常由若干个在功能上相互独立的程序段组成。在用户程序运行的某一时刻，这些相互独立的程序段不可能同时运行，因此可按程序自身的逻辑结构采用覆盖（Overlay）技术，即让那些不会同时执行的程序段共享同一块内存区。首先把这些程序段保存在外存上，仅将最初执行的部分程序段装入内存，当处于共享内存区的程序段执行结束时，再按执行顺序依次把能够覆盖的程序段调入内存的共享内存区，去覆盖已执行结束的程序段。尽管这种方法并没有真正扩充内存容量，但从效果和感觉上内存容量已经被扩充了，即达到了在逻辑上扩充内存的目的。这种技术一般要求程序各模块之间有一个明确的调用结构，用户要向系统指明覆盖结构（哪些程序段之间可以进行覆盖），然后由操作系统完成自动覆盖。因此我们把可以相互覆盖的程序段称为覆盖段，而把可供共享的内存区称为覆盖区。

通过覆盖技术来扩充内存方式，对用户提出了较高的要求，即用户要根据程序的逻辑结构将一个程序划分为不同的程序段，并预先规定好内存的覆盖区及程序的执行顺序和覆盖顺序，否则可能会导致程序段的覆盖次序与程序执行次序发生冲突。一个用户程序如何划分成不同的程序段，以及哪些程序段能够共享哪些内存空间，这些只能由用户自己决定。

覆盖技术打破了必须将一个程序的全部信息装入内存后才能运行的限制，在一定程度上，解决了小内存运行大程序的矛盾。其缺点是：**对用户不透明**，编程时必须由用户划分程序模块以及确定程序模块之间的覆盖关系，这无疑增加了用户的负担。

（2）交换技术

交换（Swapping）技术同覆盖技术一样也是利用外存在逻辑上扩充内存，它的主要特点是：打破了一个程序一旦进入内存，就一直驻留在内存直到运行结束的限制。

在多道程序环境下，内存中可以同时存在多个进程（程序），其中的一部分进程由于等待某些事件而处于阻塞状态，但这些处于阻塞状态的进程仍然驻留内存，并占据着内存空间；另一方面，外存上可能有许多等待装入内存运行的程序，却因内存不足而未能装入。显然，这是一种严重的系统资源浪费，它会使系统的吞吐量下降。为了解决这个问题，可以在操作系统中增加交换（对换）功能，即由操作系统根据需要，将内存中暂时不具备运行条件的部分程序或数据移到外存（换出），以便腾出足够的内存空间，将外存中需要运行的程序或数据调入内存（换入）投入运行。在操作系统中引入交换（对换）技术，可以显著提高内存资源的利用率并改善系统的性能。
以交换的单位不同来划分，则有以下两种交换方式。

（1）**以进程为单位的交换**。每次换入/换出的是整个进程，我们称这种交换为进程交换（进程对换）或整体交换（整体对换）。进程交换广泛应用于分时系统，主要解决内存紧张问题。

（2）**以页或段为单位的交换**。这种交换分别称为**页置换**（页交换或页对换）或**段置换**（段交换或段对换），页置换和段置换是以进程中的某一部分为交换单位，因此又称为部分交换（部分对换）。**部分交换广泛应用于现代操作系统中，是实现虚拟存储器的基础**。

我们**这里所说的交换是指进程交换**，为了实现进程交换，操作系统需要解决以下两个问题。

（1）对换空间的管理。在具有交换功能的操作系统中，一般将外存空间分为文件区和交换区（对换区）。文件区用来存放文件，而交换区则用来存放从内存中换出的进程，或等待换入内存的进程。尽管文件区一般采用离散分配方式来分配外存存储空间，但交换区的存储空间分配则宜采用连续分配方式，这是因为交换区中存放的是换入/换出的进程，为了提高交换速度，有必要采用连续分配方式，并且交换区可以采用与可变分区存储管理类似的方法进行管理。例如，使用空闲分区表或空闲分区链来记录外存交换区的使用情况，利用首次适应算法、最佳适应算法或最差适应算法来进行外存交换区的分配。

（2）交换的时机以及选择哪些进程交换。交换时机一般选择在进程的时间片用完，以及进程等待输入/输出时，或者在进程要求扩充其内存空间而得不到满足时。换出到外存的进程一般选择处于阻塞状态，或优先级低且短时间内不会再次投入运行的进程；换入到内存的进程则应选择换出时间最久且已处于就绪状态的进程。

与覆盖技术相比交换则完全由操作系统实现，它不要求用户做特殊的工作，整个交换过程**对用户是透明的**。并且交换主要是在进程或程序之间进行，而覆盖则主要是在同一个进程或同一个程序内进行。

## 四、分页式存储管理

### 实现原理

在分页存储管理中，一个程序的逻辑地址空间被划分成若干个**大小相等**的区域，每个区域称为页或页面，并且程序地址空间中所有的页从0开始顺序编号。相应地，**内存物理地址空间也按同样方式划分成与页大小相同的区域，**每个区域称为物理块或页框，与页一样内存空间中的所有物理块也从0开始顺序编号。在为程序分配内存时，允许以页为单位将程序的各个页，分别装入内存中相邻或不相邻的物理块中。**由于程序的最后一页往往不能装满分配给它的物理块，于是会有一定程度的内存空间浪费，这部分被浪费的内存空间称为页内碎片。**

分页系统中页的选择对系统性能有重要影响。若页划分得过小，虽然可以有效减少页内碎片，并提高内存利用率，但会导致每个进程需要更多的页，这样会使分页系统中用于页管理的页表增大，而占用更多的内存空间。若页划分得过大，虽然可以减少页表大小，并提高页的置换速度，但会导致页内碎片增大，而且当一个页大到能装下一个程序时就退化为分区存储管理了。因此页的大小应适中，分页系统中页的大小取决于机器的地址结构，一般设置为2的整数幂，通常为512B～8KB。

### 逻辑地址结构

在分页存储管理中，程序中的逻辑地址被转换为页号和页内地址。这个转换工作在程序执行时由系统硬件自动完成，整个过程对用户透明。因此用户编程时不需要知道逻辑地址与页号和页内地址的对应关系，只需要使用一维的逻辑地址。

程序的一维逻辑地址空间经过系统硬件自动分页后，形成“页号+页内地址”的地址结构。在下图所示的地址结构中，**逻辑地址通过页号和页内地址来共同表示。**其中，0～11位是页内地址，即每个页的大小是4KB；12～31位是页号，即地址空间最多允许有1M个页。一维逻辑地址与页号和页内地址的关系是（注：页长即一页的大小）

$$一维逻辑地址=页号×页长+页内地址$$

![image-20201030200956539](https://gitee.com/p8t/picbed/raw/master/imgs/20201030200957.png)

### 数据结构

为了实现分页存储管理，系统主要设置了以下两种表格。

（1）页表

在分页系统中，允许程序所有的页以离散方式分别存储在内存不同的物理块里，为了使程序能够正确运行，必须在内存空间中找到存放每个页的物理块。因此**操作系统为每个进程建立了一张页映射表，简称页表，用来存储页号及其映射（装入）的内存物理块号**。最简单的页表由页号及其映射的物理块号组成。由于页表的长度由程序所拥有页的个数决定，故每个程序的页表长度通常不同。

当一个程序需要很多个页时，页表就会很大，进而占用大块的连续内存空间。因此出现了多级页表，把一个大页表拆分为多个小页表，用一个页目录表记录每个小页表所在的内存块，使页表离散的分散在内存中。

（2）内存分配表

为了正确地将一个页装入到内存的某一物理块中，就必须知道内存中所有物理块的使用情况，因此系统建立一张内存分配表来记录内存中物理块的分配情况。由于每个物理块的大小相同且不会改变大小，因此最简单的办法是用一张位示图（Bitmap）来构成内存分配表。位示图是指在内存中开辟若干个字，它的每一位与内存中的一个物理块相对应。每一位的值可以是0或1，当取值为0时，表示对应的物理块空闲；当取值为1时，表示对应的物理块已分配。此外，在位示图中增加一个字节，来记录内存当前空闲物理块的总数。

## 五、分段式存储管理

存储管理从固定分区分配发展到可变分区分配，再发展到分页存储管理，主要是为了提高内存空间的利用率。但从用户角度看，以上几种管理方式都存在着自身局限性，难以满足用户在编程和使用上的多方面需求。如在分页存储管理方式中，程序的逻辑地址空间是一维线性的，虽然可以将程序划分为若干个页，但页与程序之间并不存在逻辑关系，也就很难以模块为单位来对程序进行分配、共享和保护。事实上，程序大多采用分段结构，一个程序可以由主程序段、子程序段和数据段等组成，每个段都从逻辑地址 0 开始编制，有各自的名字和长度，并实现不同的功能。若能以段为单位为程序离散分配内存空间，将满足用户多方面的需求，由此就导致了分段存储管理的出现。

### 实现原理

在分段存储管理中，系统将程序的逻辑地址空间分成若干个逻辑分段，如主程序段、子程序段、数据段和工作区段等，每个分段都是一组逻辑意义完整的信息集合，且有各自的段名或段号，即在逻辑上是各自独立的。每个段都是从 0 开始编址的一维连续地址空间，其长度由段自身包含的逻辑信息长度决定，所以各段的长度可以不同，整个程序的所有段则构成了二维地址空间。在为程序分配内存时，允许以段为单位将程序离散地装入相邻或不相邻的内存空间中，而每个段则占用一段连续的内存区域，系统通过地址转换机构，将段的逻辑地址转换为实际的内存物理地址，从而使程序能够正确执行。

### 逻辑地址结构

在分段存储管理中，由于程序的地址空间被分成若干个段，因此程序的逻辑地址是二维的，即程序的逻辑地址由段号（段名）和段内地址两部分组成。段号和段内地址都是从 0开始编址，段号范围决定了程序中最多允许有多少个段，段内地址的范围则决定了每个段的最大长度。在图所示的地址结构中，一个程序最多允许 256（$$2^8$$）个段，每个段的最大长度为16MB（$$2^{24}$$）。

![image-20201030203328650](https://gitee.com/p8t/picbed/raw/master/imgs/20201030203329.png)

在现代操作系统中，绝大多数编译程序都支持分段方式，因此用户程序如何分段这个问题对用户来说是透明的，即可以由编译程序根据源程序的情况自动产生若干个段。

### 段表

在分段存储管理中，程序的各段以离散分配方式装入到内存中相邻或不相邻的空闲分区，即内存中各段之间可以不连续，但每个段在所装入的分区中是连续的。为了使程序正常运行，必须要找到每个逻辑段在内存中具体的物理存储位置，即实现将二维逻辑地址转换为一维物理地址，这项工作通过段映射表（简称段表）来完成。系统为每个程序建立了一个段表，程序的每个段在段表中有一个段表项，这个段表项记录了该段的段名（段号），该段在内存中的起始地址（内存始址）以及该段的长度（段长）等信息。

## 六、段页式存储管理

段页式存储管理结合了分段存储管理和分页存储管理的优点，在为程序分配内存空间时，采用的是“各段之间按分段存储管理进行分配，每个段内部则按分页存储管理进行分配”的原则。首先，根据程序自身的逻辑结构，运用分段存储管理的思想，把程序的逻辑地址空间划分为若干个段，每个段有各自的段名或段号；然后，再依据分页存储管理的方法，在每个段内按页的大小，将该段划分为不同的页，段内的这些页从 0开始顺序编号。内存空间的管理则只按页的大小划分为若干个的物理块，并且内存中所有物理块从 0开始顺序编号。在为程序分配内存空间时，允许以页为单位，一次性将一个程序中每个段的所有页装入内存若干相邻或不相邻的物理块中。在此需要强调的是，在分段存储管理中，尽管程序的各个段以离散方式装入到内存中，但每个段在内存中仍需连续，因此段的大小仍然受到内存空闲区大小的限制。然而在段页式存储管理中，由于对段又进行了分页，即逻辑地址空间中的最小单位是页，内存空间也被划分为与页大小相等的若干物理块。分配以页为单位进行，因此每个段包含的所有页在内存中也实现了离散存储（即这些页可以存储到内存不相邻的物理块中）。

### 逻辑地址结构

在段页式存储管理中，一个程序的逻辑地址结构由段号、段内页号和页内地址这三部分组成，如下图所示。

![image-20201030204633934](https://gitee.com/p8t/picbed/raw/master/imgs/20201030204634.png)

程序的逻辑地址仍然是一个二维地址空间，用户可见的仍然是段号和段内地址，而地址转换机构，则根据系统要求自动把段内地址分为两部分，高位部分为页号（段内页号），低位部分为页内地址。假定逻辑地址长度为 32位，若段号占 8位，段内页号占 12位，页内地址占 12位，则一个程序最多允许有 256（$$2^8$$）个段，每段最多允许 4096（$$2^{12}$$）个页，每页的大小为4KB（$$2^{12}$$）。

### 数据结构

为了实现段页式存储管理，系统必须设置以下两种数据结构。

（1）段表。系统为每个程序建立一张段表，程序的每个段在段表中有一个段表项，此段表项记录了该段的页表长度和页表始址（页表在内存中存放的起始地址）。

（2）页表。系统为程序中的每个段都建立一张页表，一个段中的每个页在该段的页表中都有一个页表项，每个页表项记录了一个页的页号及其映射的内存物理块号。

## 七、虚拟存储管理

### 概念

虚拟内存是对物理内存的抽象，使得每个进程看到的内存空间都是一致的、连续的，而实际上这些内存是离散的分布在物理内存中，而且还有部分分布在外存中。

虚拟存储就是外存对内存的补充。有了虚拟存储，程序只加载一部分进内存，剩下的先放在外存（虚拟存储）中，等需要用到时再加载（缺页中断），加载新页进内存并把暂时不需要的页移出内存的过程称为**页面置换**，这样实现的理论支持是**程序的局部性原理**。

目的是解决内存资源不够用的问题

### 页面置换算法

**进程执行过程中，若要访问的页不在内存，缺页中断机构就产生缺页中断，以便将所需页调入内存。**如果此时内存已没有空闲的物理块来装入需要调入的页，则系统必须从内存中选择一个页换出至外存，以便腾出内存空间来存放要调入的页，但将哪个页换出则必须通过页置换算法确定。页置换算法的好坏对系统的性能有重要影响，好的页置换算法应具有较低的页更换频率。从理论上讲，应该把今后不会再访问的页置换出去，或者把最长时间内不会再访问的页置换出去。常用的页置换算法有以下三种。

（1）最佳置换算法

最佳置换（Optimal，OPT）算法是由Belady于1966年提出的一种理论上的算法。算法的实质是系统预测进程今后要访问页序列，需要进行页置换时，所选择的置换页是那些将来不会被访问的页，或者是在最长时间后才被访问的页，即置换该页不会造成刚将此页置换出内存又要立即把它再置换回内存的情况出现。

**最佳置换算法是一种理想化的置换算法**，可以获得最低缺页中断率，性能也最好。该算法要求系统能够知道进程“将来”使用页的情况，但这是不现实的，因为进程执行过程中，访问页的轨迹是不可预知的，不过该算法可用于理论上对比分析其他置换算法的优劣。

（2）先进先出算法

先进先出（First Input First Output，FIFO）算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。该算法实现简单，只需把一个进程已调入内存的页按先后次序链接成一个队列，并设置一个指针（称为替换指针），使它总是指向最老（最早调入）的页。但该算法淘汰页的顺序不一定与进程实际运行中调用页的顺序相符，因为在进程运行中有些页经常被访问，如含有全局变量、常用函数、例程等的页。

对于一些经常访问的页，先进先出置换算法并不能保证这些页不会被淘汰，很可能一些刚换出至外存的页很快又会被调入内存。此外，该算法有时还会产生一种陷阱现象（称为 Belady现象），即增加分配给进程的物理块数可能不会使进程的缺页率降低，反而会使缺页率上升。

（3）最近最久未使用算法（LRU）

先进先出算法之所以性能较差，是因为它所依据的条件是各个页调入内存的时间，而页调入的先后并不能反映页的实际使用情况。而最近最久未使用（Least Recently Used，LRU）算法则根据某页调入内存后的使用情况来确定该页的调出，即如果某页最近被访问了，则不久之后还可能被访问；反之，如果某页在最近的过去有很长一段时间未被访问，则在最近的将来这一段时间内该页也可能不会被访问。由于无法预测各页将来的使用情况，则只能利用“最近的过去”作为“最近的将来”的一种近似。也就是说，LRU算法是根据前面页的使用历史来决定未来页的使用。因此根据历史情况，LRU算法是选择最近最久未使用的页予以淘汰， 即 OPT算法是“向后看”，而 LRU算法则“向前看”。

虽然 LRU算法在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个由所有页组成的链表，最近使用最多的页在表头，最近最久未使用的页在表尾，并且每次访问内存时都必须更新该链表，即找到链表中当前访问的页（成为最近使用最多的页），将其摘下来移到链表的表头，这无疑会增大系统的开销。所以在具体实现中，一般都是采用该算法的近似算法。

（4）最不经常使用算法（LFU）

在需要淘汰一个页时，首先淘汰截至目前时间访问次数最少的那个页。该算法实现比较简单，在页表项中增设一个访问计数器就可以解决问题。具体方法是当某个页被访问一次时，该计数器加 1；在发生缺页中断需要从内存中淘汰一个页时，就根据访问计数器的值，淘汰值最小的那个页，同时将所有的计数器清0。

（5） 时钟算法（Clock）

为每个页增设一个访问位，初始为0，当某个页被访问时，该页的访问位置1。

把内存中的页都保存在一个循环链表中，且该循环链表中的页排成一个时钟形状，一个链表指针指向最老的页。

当发生缺页中断时，时钟算法首先检查链表指针指向的页，如果它的访问位是 0，就淘汰该页，并把外存中的页换入到该页的位置，然后把链表指针移向下一个页位置；如果访问位是 1，就将访问位清 0（相当于刚访问，即给该页第二次机会），并把链表指针移向下一个页位置。重复这一过程直到找到一个访问位为0的页为止。

### 小结

选择合适的页置换算法对系统来说非常重要，若选用的置换算法不合适就会出现这种现象，即内存中刚被调出的页又要立即使用，因此又将其调入内存，而调入内存不久又再次淘汰（调出），淘汰不久又再次调入。如此反复，使得整个系统的页调度非常频繁，以至于 CPU的大部分时间不是用来完成进程任务，而是花费在页的调入调出上，我们把这种现象称为“抖动”（Thrashing），又称“颠簸”。抖动使 CPU的利用率降低，一个好的调度算法应减少和避免抖动的发生。

